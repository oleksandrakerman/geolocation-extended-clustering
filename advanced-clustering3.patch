diff --git a/css/geolocation-common-map.css b/css/geolocation-common-map.css
index 01258f2..8e843e0 100644
--- a/css/geolocation-common-map.css
+++ b/css/geolocation-common-map.css
@@ -14,3 +14,21 @@
   box-shadow: 0 2px 2px rgba(0,0,0,0.2);
   font-family: Arial, sans-serif;
 }
+
+.geolocation-info-contrainer {
+  overflow: hidden;
+}
+
+.geolocation-info-ul {
+  margin-bottom: 20px;
+  position: relative;
+  padding: 0;
+  left: 0;
+  top: 0;
+  transition: left .5s;
+  -webkit-transition: left .5s;
+}
+
+.geolocation-info-ul li {
+  vertical-align: top;
+}
diff --git a/geolocation.libraries.yml b/geolocation.libraries.yml
index 7aa847c..ce37cf9 100644
--- a/geolocation.libraries.yml
+++ b/geolocation.libraries.yml
@@ -90,6 +90,7 @@ geolocation.commonmap:
       css/geolocation-common-map.css: {}
   js:
     js/geolocation-common-map.js: {}
+    js/markerclusterer.js: {}
   dependencies:
     - core/drupal
     - core/drupalSettings
@@ -98,20 +99,19 @@ geolocation.commonmap:
     - core/jquery.once
     - geolocation/geolocation.googlemapsapi
 
-# External marker clusterer.
-geolocation.markerclusterer:
-  remote: https://github.com/googlemaps/js-marker-clusterer
-  version: 1.x
-  license:
-    name: Apache License, Version 2.0
-    url: http://www.apache.org/licenses/LICENSE-2.0
-    gpl-compatible: true
-  js:
-    https://cdn.rawgit.com/googlemaps/js-marker-clusterer/gh-pages/src/markerclusterer.js: { type: external }
-
 # Form element library.
 geolocation.google_map_form_element:
   js:
     js/geolocation-google-map-form-element.js: {}
   dependencies:
-    - geolocation/geolocation.googlemapsapi
\ No newline at end of file
+    - geolocation/geolocation.googlemapsapi
+
+# https://github.com/atmist/snazzy-info-window
+geolocation.snazzy-info-window:
+  version: 1.x
+  js:
+    https://maps.googleapis.com/maps/api/js?key=AIzaSyBlCjQ8rqhSLz1QAxkODlkgMPn3lUPiADI: { type: external }
+    js/snazzy-info-window.js: {}
+  css:
+    theme:
+      ../../../libraries/snazzy-info-window/dist/snazzy-info-window.css: {}
diff --git a/js/geolocation-common-map.js b/js/geolocation-common-map.js
index a318c32..44dfa65 100644
--- a/js/geolocation-common-map.js
+++ b/js/geolocation-common-map.js
@@ -81,6 +81,20 @@
        */
       function (mapId, commonMapSettings) {
 
+        // Check if advanced clustering is enabled.
+        var advanced = false;
+
+        if (commonMapSettings.markerClusterer !== undefined
+          && commonMapSettings.markerClusterer.advanced) {
+          advanced = commonMapSettings.markerClusterer.advanced;
+        }
+
+        // Check if advanced clustering is enabled.
+        var snazzy = false;
+        if (commonMapSettings.snazzy) {
+          snazzy = commonMapSettings.snazzy;
+        }
+
         /*
          * Hide form if requested.
          */
@@ -347,7 +361,7 @@
         /**
          * Result handling.
          */
-        // A Google Maps API tool to re-center the map on its content.
+          // A Google Maps API tool to re-center the map on its content.
         var bounds = new google.maps.LatLngBounds();
         Drupal.geolocation.removeMapMarker(geolocationMap);
 
@@ -370,7 +384,9 @@
             map: geolocationMap.googleMap,
             title: location.children('.location-title').html(),
             infoWindowContent: location.html(),
-            infoWindowSolitary: true
+            infoWindowSolitary: true,
+            dvanced: advanced,
+            snazzy: snazzy
           };
 
           if (typeof location.data('icon') !== 'undefined') {
@@ -500,10 +516,176 @@
             geolocationMap.googleMap,
             geolocationMap.mapMarkers,
             {
+              zoomOnClick: !advanced,
+              averageCenter: true,
               imagePath: imagePath,
-              styles: markerClustererStyles
+              styles: [markerClustererStyles]
             }
           );
+
+          // Advanced clustering.
+          if (advanced) {
+            geolocationMap.markerClusterer.setCalculator(function (markers, numStyles) {
+              var index = 0, count = markers.length, dv = count, result = {};
+              while (dv > 0) {
+                dv = parseInt(dv - 5, 10);
+                index++;
+              }
+
+              index = Math.min(index, numStyles);
+
+              var custom_id = markers[0].position.lat() + '|' + markers[0].position.lng();
+
+              result = {
+                text: '<span data-cluster-id="' + custom_id + '">' + count + '<span/>',
+                index: index
+              };
+
+              return result;
+            });
+
+            // Bind click on cluster marker.
+            google.maps.event.addListener(geolocationMap.markerClusterer, 'clusterclick', function (cluster) {
+
+              // Revert to default all clusters icons before opening new one.
+              $.each(geolocationMap.markerClusterer.clusters_, function (i, v) {
+                Drupal.geolocation.geolocationAdjustClusterIcon(v);
+              });
+
+              // Changed opened cluster icon.
+              Drupal.geolocation.geolocationAdjustClusterIcon(cluster, 0);
+
+              var markers = cluster.markers_;
+              var markers_count = markers.length;
+
+              if (markers_count) {
+                // If there are more than "zoom_at" items in cluster
+                // or if we have not reached max zoom.
+                if (!cluster.equal && (geolocationMap.googleMap.zoom < geolocationMap.googleMap.maxZoom)) {
+                  geolocationMap.googleMap.fitBounds(cluster.getBounds());
+                }
+                else {
+                  // Get first marker in the cluster.
+                  var firstMarker = markers[0];
+
+                  if (firstMarker) {
+                    var $wrapper = $('<div/>');
+
+                    var $container = $('<div/>')
+                      .addClass('geolocation-info-contrainer')
+                      .appendTo($wrapper);
+
+                    var $ul = $('<ul/>')
+                      .addClass('geolocation-info-ul')
+                      .appendTo($container);
+
+                    $.each(markers, function (index, marker) {
+                      $('<li/>')
+                        .addClass('geolocation-info-li')
+                        .addClass(index == 0 ? 'geolocation-info-li-active' : '')
+                        .attr('data-geolocation-index', index + 1)
+                        .html(marker.infoWindowContent)
+                        .appendTo($ul);
+                    });
+
+                    // Pager counter and controls.
+                    var $pager = $('<div/>')
+                      .addClass('geolocation-pager')
+                      .appendTo($container);
+
+                    $('<a/>')
+                      .addClass('geolocation-pager-prev')
+                      .text('<')
+                      .attr('href', '#')
+                      .appendTo($pager);
+
+                    var page_counters = $('<span/>')
+                      .addClass('geolocation-pager-counters')
+                      .appendTo($pager);
+
+                    $('<span/>').addClass('geolocation-pager-first')
+                      .text('1')
+                      .appendTo(page_counters);
+
+                    $('<span/>').addClass('geolocation-pager-divider')
+                      .text('/')
+                      .appendTo(page_counters);
+
+                    $('<span/>').addClass('geolocation-pager-total')
+                      .text(markers_count)
+                      .appendTo(page_counters);
+
+                    $('<a/>')
+                      .addClass('geolocation-pager-next')
+                      .text('>')
+                      .attr('href', '#')
+                      .appendTo($pager);
+
+                    var position = new google.maps.LatLng(cluster.center_.lat(), cluster.center_.lng());
+                    var autopan = geolocationMap.settings.google_map_settings.disableAutoPan;
+
+                    if (snazzy) {
+                      var infoWindow = new SnazzyInfoWindow({
+                        content: $wrapper.html(),
+                        panOnOpen: !autopan,
+                        wrapperClass: 'geolocation-info-window',
+                        map: geolocationMap.googleMap,
+                        position: position,
+                        offset: {
+                          top: '-57px'
+                        },
+                        callbacks: {
+                          beforeOpen: function () {},
+                          open: function () {},
+                          afterOpen: function () {
+                            Drupal.geolocation.adjustInside(cluster);
+                            Drupal.behaviors.oktoproMapTabs.attach();
+                          },
+                          beforeClose: function () {},
+                          close: function () {
+                            Drupal.geolocation.geolocationAdjustClusterIcon(cluster);
+                          },
+                          afterClose: function () {}
+                        }
+                      });
+
+                      if (typeof geolocationMap.infoWindow !== 'undefined') {
+                        geolocationMap.infoWindow.destroy();
+                      }
+
+                      geolocationMap.infoWindow = infoWindow;
+
+                      infoWindow.open();
+                    }
+                    else {
+                      infoWindow = new google.maps.InfoWindow({
+                        content: $wrapper.html(),
+                        disableAutoPan: autopan,
+                        position: position
+                      });
+
+                      // Revert cluster icon after popup closed.
+                      google.maps.event.addListener(infoWindow, "closeclick", function () {
+                        Drupal.geolocation.geolocationAdjustClusterIcon(cluster);
+                      });
+
+                      // Close all info windows.
+                      if (firstMarker.infoWindowSolitary) {
+                        if (typeof geolocationMap.googleMap.infoWindow !== 'undefined') {
+                          geolocationMap.googleMap.infoWindow.close();
+                        }
+                        geolocationMap.googleMap.infoWindow = infoWindow;
+                      }
+
+                      // Open info window.
+                      infoWindow.open(geolocationMap.googleMap);
+                      Drupal.geolocation.adjustInside(cluster);
+                    }
+                  }
+                }
+              }
+            });
+          }
         }
 
         if (mapWrapper.data('fitbounds') === 1) {
@@ -571,4 +753,79 @@
     }
   };
 
+  /**
+   * Convert inner content of popup into pager.
+   *
+   * @param cluster
+   */
+  Drupal.geolocation.adjustInside = function (cluster) {
+    // Adjust items and wrapper size.
+    var width = 0;
+    var total_width = 0;
+    var height = 0;
+    var $items = $('.geolocation-info-ul li.geolocation-info-li');
+
+    $items.each(function () {
+      var this_width = $(this).width();
+      var this_height = $(this).height();
+
+      width = this_width > width ? this_width : width;
+      // Overflow-hidden wrapper width.
+      $('.geolocation-info-contrainer').width(width);
+      height = this_height > height ? this_height : height;
+
+      total_width = parseFloat(total_width) + parseFloat(width);
+    });
+
+    // Overflow-hidden wrapper width.
+    $('.geolocation-info-contrainer').width(width);
+
+    // Pager items size.
+    $items.width(width).height(height)
+      .css('display', 'inline-block');
+
+    // Ul size.
+    $('.geolocation-info-ul')
+      .width(total_width)
+      .height(height);
+
+    // Pagination function.
+    var geolocationPagination = function (direction) {
+      var $active_item = $('li.geolocation-info-li-active');
+      var active = $active_item.attr('data-geolocation-index');
+      active = parseInt(active);
+
+      var total = $('.geolocation-pager-total').text();
+      total = parseInt(total);
+
+      if (direction == 'next' ? active < total : active > 1) {
+        var next = direction == 'next' ? active + 1 : active - 1;
+
+        $active_item.removeClass('geolocation-info-li-active');
+
+        $('li[data-geolocation-index="' + next + '"]')
+          .addClass('geolocation-info-li-active');
+
+        $('.geolocation-pager-first').text(next);
+
+        var left_skip = (next - 1) * width;
+        $('.geolocation-info-ul').css('left', -left_skip);
+
+        // Change the cluster icon.
+        Drupal.geolocation
+          .geolocationAdjustClusterIcon(cluster, next - 1);
+      }
+    };
+
+    $('.geolocation-pager-next').click(function (e) {
+      e.preventDefault();
+      geolocationPagination('next');
+    });
+
+    $('.geolocation-pager-prev').click(function (e) {
+      e.preventDefault();
+      geolocationPagination('prev');
+    });
+  };
+
 })(jQuery, window, Drupal, drupalSettings);
diff --git a/js/geolocation-google-maps-api.js b/js/geolocation-google-maps-api.js
index 69e0be4..44dfa65 100644
--- a/js/geolocation-google-maps-api.js
+++ b/js/geolocation-google-maps-api.js
@@ -1,541 +1,831 @@
 /**
  * @file
- *   Javascript for the geolocation module.
+ * Handle the common map.
  */
 
 /**
- * @param {Object} drupalSettings.geolocation
- * @param {String} drupalSettings.geolocation.google_map_url
+ * @name CommonMapUpdateSettings
+ * @property {String} enable
+ * @property {String} hide_form
+ * @property {number} views_refresh_delay
+ * @property {String} update_view_id
+ * @property {String} update_view_display_id
+ * @property {String} boundary_filter
+ * @property {String} parameter_identifier
  */
 
 /**
- * @name GoogleMapSettings
- * @property {String} info_auto_display
- * @property {String} marker_icon_path
- * @property {String} height
- * @property {String} width
- * @property {Number} zoom
- * @property {Number} maxZoom
- * @property {Number} minZoom
- * @property {String} type
- * @property {Boolean} scrollwheel
- * @property {Boolean} preferScrollingToZooming
- * @property {String} gestureHandling
- * @property {Boolean} panControl
- * @property {Boolean} mapTypeControl
- * @property {Boolean} scaleControl
- * @property {Boolean} streetViewControl
- * @property {Boolean} overviewMapControl
- * @property {Boolean} zoomControl
- * @property {Boolean} rotateControl
- * @property {Boolean} fullscreenControl
- * @property {Object} zoomControlOptions
- * @property {String} mapTypeId
- * @property {String} info_text
- */
-
-/**
- * @typedef {Object} GoogleMapBounds
- * @property {function():GoogleMapLatLng} getNorthEast
- * @property {function():GoogleMapLatLng} getSouthWest
- */
-
-/**
- * @typedef {Object} GoogleMapLatLng
- * @property {function():float} lat
- * @property {function():float} lng
- */
-
-/**
- * @typedef {Object} GoogleMapPoint
- * @property {function():float} x
- * @property {function():float} y
- */
-
-/**
- * @typedef {Object} AddressComponent
- * @property {String} long_name - Long component name
- * @property {String} short_name - Short component name
- * @property {String[]} types - Component type
- * @property {GoogleGeometry} geometry
- */
-
-/**
- * @typedef {Object} GoogleAddress
- * @property {AddressComponent[]} address_components - Components
- * @property {String} formatted_address - Formatted address
- * @property {GoogleGeometry} geometry - Geometry
- */
-
-/**
- * @typedef {Object} GoogleGeometry
- * @property {GoogleMapLatLng} location - Location
- * @property {String} location_type - Location type
- * @property {GoogleMapBounds} viewport - Viewport
- * @property {GoogleMapBounds} bounds - Bounds (optionally)
- */
-
-/**
- * @typedef {Object} GoogleMapProjection
- * @property {function(GoogleMapLatLng):GoogleMapPoint} fromLatLngToPoint
- */
-
-/**
- * @typedef {Object} GoogleMarkerSettings
- *
- * Settings from https://developers.google.com/maps/documentation/javascript/3.exp/reference#MarkerOptions:
- * @property {GoogleMapLatLng} position
- * @property {GoogleMap} map
- * @property {string} title
- * @property {string} [icon]
- * @property {string} [label]
- *
- * Settings from Geolocation module:
- * @property {string} [infoWindowContent]
- * @property {boolean} [infoWindowSolitary]
- */
-
-/**
- * @typedef {Object} GoogleMarker
- * @property {Function} setPosition
- * @property {Function} setMap
- * @property {Function} setIcon
- * @property {Function} setTitle
- * @property {Function} setLabel
- * @property {Function} addListener
- */
-
-/**
- * @typedef {Object} GoogleInfoWindow
- * @property {Function} open
- * @property {Function} close
- */
-
-/**
- * @typedef {Object} GoogleCircle
- * @property {function():GoogleMapBounds} Circle.getBounds()
- */
-
-/**
- * @typedef {Object} GoogleMap
- * @property {Object} ZoomControlStyle
- * @property {String} ZoomControlStyle.LARGE
- *
- * @property {Object} ControlPosition
- * @property {String} ControlPosition.LEFT_TOP
- * @property {String} ControlPosition.TOP_LEFT
- * @property {String} ControlPosition.RIGHT_BOTTOM
- * @property {String} ControlPosition.RIGHT_CENTER
- *
- * @property {Object} MapTypeId
- * @property {String} MapTypeId.ROADMAP
- *
- * @property {Function} LatLngBounds
- *
- * @function
- * @property Map
- *
- * @function
- * @property InfoWindow
- *
- * @function
- * @property {function({GoogleMarkerSettings}):GoogleMarker} Marker
- *
- * @function
- * @property {function({}):GoogleInfoWindow} InfoWindow
- *
- * @function
- * @property {function(string|number|float, string|number|float):GoogleMapLatLng} LatLng
- *
- * @function
- * @property {function(string|number|float, string|number|float):GoogleMapPoint} Point
- *
- * @property {function(Object):GoogleCircle} Circle
- *
- * @property {function():GoogleMapProjection} getProjection
- *
- * @property {Function} fitBounds
- *
- * @property {Function} setCenter
- * @property {Function} setZoom
- * @property {Function} getZoom
- * @property {Function} setOptions
- *
- * @property {function():GoogleMapBounds} getBounds
- * @property {function():GoogleMapLatLng} getCenter
- */
-
-/**
- * @typedef {Object} google
- * @property {GoogleMap} maps
- * @property {Object} event
- * @property {Function} addListener
- * @property {Function} addDomListener
- * @property {Function} addListenerOnce
- * @property {Function} addDomListenerOnce
+ * @name CommonMapSettings
+ * @property {Object} settings
+ * @property {GoogleMapSettings} settings.google_map_settings
+ * @property {CommonMapUpdateSettings} dynamic_map
+ * @property {String} client_location.enable
+ * @property {String} client_location.update_map
+ * @property {Boolean} showRawLocations
+ * @property {Boolean} markerScrollToResult
+ * @property {String} markerClusterer.enable
+ * @property {String} markerClusterer.imagePath
+ * @property {Object} markerClusterer.styles
+ * @property {String} contextPopupContent.enable
+ * @property {String} contextPopupContent.content
  */
 
 /**
- * @typedef {Object} GeolocationMap
- * @property {string} id
- * @property {Object} settings
- * @property {GoogleMapSettings} settings.google_map_settings
- * @property {GoogleMap} googleMap
- * @property {Number} lat
- * @property {Number} lng
- * @property {jQuery} container
- * @property {GoogleMarker[]} mapMarkers
- * @property {GoogleInfoWindow} infoWindow
+ * @property {CommonMapSettings[]} drupalSettings.geolocation.commonMap
  */
 
 /**
- * Callback when map fully loaded.
- *
- * @callback geolocationMapLoadedCallback
- * @param {GeolocationMap} map - Google map.
+ * @property {function(CommonMapUpdateSettings)} GeolocationMap.updateDrupalView
+ * @property {Object} GeolocationMap.markerClusterer
  */
 
-(function ($, _, Drupal, drupalSettings) {
+(function ($, window, Drupal, drupalSettings) {
   'use strict';
 
   /* global google */
 
-  /**
-   * JSLint handing.
-   *
-   *  @callback geolocationCallback
-   */
+  var skipMapIdleEventHandler = false; // Setting to true will skip the next triggered map related viewsRefresh.
 
   /**
    * @namespace
    */
   Drupal.geolocation = Drupal.geolocation || {};
 
-  Drupal.geolocation.maps = Drupal.geolocation.maps || [];
-
-  // Google Maps are loaded lazily. In some situations load_google() is called twice, which results in
-  // "You have included the Google Maps API multiple times on this page. This may cause unexpected errors." errors.
-  // This flag will prevent repeat $.getScript() calls.
-  Drupal.geolocation.maps_api_loading = false;
-
-  /** {GoogleMapSettings} **/
-  Drupal.geolocation.defaultMapSettings = {
-    scrollwheel: false,
-    panControl: false,
-    mapTypeControl: true,
-    scaleControl: false,
-    streetViewControl: false,
-    overviewMapControl: false,
-    rotateControl: false,
-    fullscreenControl: false,
-    zoomControl: true,
-    mapTypeId: 'roadmap',
-    zoom: 2,
-    maxZoom: 0,
-    minZoom: 18,
-    style: [],
-    gestureHandling: 'auto'
-  };
-
   /**
-   * Provides the callback that is called when maps loads.
-   */
-  Drupal.geolocation.googleCallback = function () {
-    // Ensure callbacks array;
-    Drupal.geolocation.googleCallbacks = Drupal.geolocation.googleCallbacks || [];
-
-    // Wait until the window load event to try to use the maps library.
-    $(document).ready(function (e) {
-      _.invoke(Drupal.geolocation.googleCallbacks, 'callback');
-      Drupal.geolocation.googleCallbacks = [];
-    });
-  };
-
-  /**
-   * Adds a callback that will be called once the maps library is loaded.
+   * Attach common map style functionality.
    *
-   * @param {geolocationCallback} callback - The callback
-   */
-  Drupal.geolocation.addCallback = function (callback) {
-    Drupal.geolocation.googleCallbacks = Drupal.geolocation.googleCallbacks || [];
-    Drupal.geolocation.googleCallbacks.push({callback: callback});
-  };
-
-  /**
-   * Load Google Maps and set a callback to run when it's ready.
+   * @type {Drupal~behavior}
    *
-   * @param {geolocationCallback} callback - The callback
+   * @prop {Drupal~behaviorAttach} attach
+   *   Attaches common map style functionality to relevant elements.
    */
-  Drupal.geolocation.loadGoogle = function (callback) {
-    // Add the callback.
-    Drupal.geolocation.addCallback(callback);
-
-    // Check for Google Maps.
-    if (typeof google === 'undefined' || typeof google.maps === 'undefined') {
-      if (Drupal.geolocation.maps_api_loading === true) {
-        return;
-      }
-
-      Drupal.geolocation.maps_api_loading = true;
-      // Google Maps isn't loaded so lazy load Google Maps.
-
-      if (typeof drupalSettings.geolocation.google_map_url !== 'undefined') {
-        $.getScript(drupalSettings.geolocation.google_map_url)
-          .done(function () {
-            Drupal.geolocation.maps_api_loading = false;
-          });
-      }
-      else {
-        console.error('Geolocation - Google map url not set.'); // eslint-disable-line no-console
+  Drupal.behaviors.geolocationCommonMap = {
+    attach: function (context, drupalSettings) {
+      if (typeof Drupal.geolocation.loadGoogle === 'function') {
+        // First load the library from google.
+        Drupal.geolocation.loadGoogle(function () {
+          initialize(drupalSettings.geolocation, context);
+        });
       }
     }
-    else {
-      // Google Maps loaded. Run callback.
-      Drupal.geolocation.googleCallback();
-    }
   };
 
-  /**
-   * Load Google Maps and set a callback to run when it's ready.
-   *
-   * @param {GeolocationMap} map - Container of settings and ID.
-   *
-   * @return {object} - The Google Map object.
-   */
-  Drupal.geolocation.addMap = function (map) {
+  function initialize(settings, context) {
 
-    if (typeof map.id === 'undefined') {
-      map.id = 'map' + Math.floor(Math.random() * 10000);
-    }
+    $.each(
+      settings.commonMap,
 
-    map.mapMarkers = map.mapMarkers || [];
+      /**
+       * @param {String} mapId - canvasId of current map
+       * @param {CommonMapSettings} commonMapSettings - settings for current map
+       */
+      function (mapId, commonMapSettings) {
 
-    // Set the container size.
-    map.container.css({
-      height: map.settings.google_map_settings.height,
-      width: map.settings.google_map_settings.width
-    });
+        // Check if advanced clustering is enabled.
+        var advanced = false;
 
-    // Get the center point.
-    var center = new google.maps.LatLng(map.lat, map.lng);
-
-    // Add any missing settings.
-    map.settings.google_map_settings = $.extend(Drupal.geolocation.defaultMapSettings, map.settings.google_map_settings);
-
-    map.settings.google_map_settings.zoom = parseInt(map.settings.google_map_settings.zoom) || Drupal.geolocation.defaultMapSettings.zoom;
-    map.settings.google_map_settings.maxZoom = parseInt(map.settings.google_map_settings.maxZoom) || Drupal.geolocation.defaultMapSettings.maxZoom;
-    map.settings.google_map_settings.minZoom = parseInt(map.settings.google_map_settings.minZoom) || Drupal.geolocation.defaultMapSettings.minZoom;
-
-     /**
-     * Create the map object and assign it to the map.
-     *
-     * @type {GoogleMap} map.googleMap
-     */
-    map.googleMap = new google.maps.Map(map.container.get(0), {
-      zoom: map.settings.google_map_settings.zoom,
-      maxZoom: map.settings.google_map_settings.maxZoom,
-      minZoom: map.settings.google_map_settings.minZoom,
-      center: center,
-      mapTypeId: google.maps.MapTypeId[map.settings.google_map_settings.type],
-      mapTypeControlOptions: {
-        position: google.maps.ControlPosition.RIGHT_BOTTOM
-      },
-      rotateControl: map.settings.google_map_settings.rotateControl,
-      fullscreenControl: map.settings.google_map_settings.fullscreenControl,
-      zoomControl: map.settings.google_map_settings.zoomControl,
-      zoomControlOptions: {
-        style: google.maps.ZoomControlStyle.LARGE,
-        position: google.maps.ControlPosition.RIGHT_CENTER
-      },
-      streetViewControl: map.settings.google_map_settings.streetViewControl,
-      streetViewControlOptions: {
-        position: google.maps.ControlPosition.RIGHT_CENTER
-      },
-      mapTypeControl: map.settings.google_map_settings.mapTypeControl,
-      scrollwheel: map.settings.google_map_settings.scrollwheel,
-      disableDoubleClickZoom: map.settings.google_map_settings.disableDoubleClickZoom,
-      draggable: map.settings.google_map_settings.draggable,
-      styles: map.settings.google_map_settings.style,
-      gestureHandling: map.settings.google_map_settings.gestureHandling
-    });
+        if (commonMapSettings.markerClusterer !== undefined
+          && commonMapSettings.markerClusterer.advanced) {
+          advanced = commonMapSettings.markerClusterer.advanced;
+        }
 
-    if (map.settings.google_map_settings.scrollwheel && map.settings.google_map_settings.preferScrollingToZooming) {
-      map.googleMap.setOptions({scrollwheel: false});
-      map.googleMap.addListener('click', function () {
-        map.googleMap.setOptions({scrollwheel: true});
-      });
-    }
+        // Check if advanced clustering is enabled.
+        var snazzy = false;
+        if (commonMapSettings.snazzy) {
+          snazzy = commonMapSettings.snazzy;
+        }
 
-    Drupal.geolocation.maps.push(map);
+        /*
+         * Hide form if requested.
+         */
+        if (
+          typeof commonMapSettings.dynamic_map !== 'undefined'
+          && commonMapSettings.dynamic_map.enable
+          && commonMapSettings.dynamic_map.hide_form
+          && typeof commonMapSettings.dynamic_map.parameter_identifier !== 'undefined'
+        ) {
+          var exposedForm = $('form#views-exposed-form-' + commonMapSettings.dynamic_map.update_view_id.replace(/_/g, '-') + '-' + commonMapSettings.dynamic_map.update_view_display_id.replace(/_/g, '-'));
+
+          if (exposedForm.length === 1) {
+            exposedForm.find('input[name^="' + commonMapSettings.dynamic_map.parameter_identifier + '"]').each(function (index, item) {
+              $(item).parent().hide();
+            });
+
+            // Hide entire form if it's empty now, except form-submit.
+            if (exposedForm.find('input:visible:not(.form-submit), select:visible').length === 0) {
+              exposedForm.hide();
+            }
+          }
+        }
 
-    google.maps.event.addListenerOnce(map.googleMap, 'tilesloaded', function () {
-      Drupal.geolocation.mapLoadedCallback(map, map.id);
-    });
+        // The DOM-node the map and everything else resides in.
+        /** @type {jQuery} */
+        var mapWrapper = $('#' + mapId, context);
 
-    return map.googleMap;
-  };
+        // If the map is not present, we can go to the next entry.
+        if (!mapWrapper.length) {
+          return;
+        }
 
-  /**
-   * Set/Update a marker on a map
-   *
-   * @param {GeolocationMap} map - The settings object that contains all of the necessary metadata for this map.
-   * @param {GoogleMarkerSettings} markerSettings - Marker settings.
-   * @param {Boolean} [skipInfoWindow=false] - Skip attaching InfoWindow.
-   * @return {GoogleMarker} - Created marker.
-   */
-  Drupal.geolocation.setMapMarker = function (map, markerSettings, skipInfoWindow) {
-    map.mapMarkers = map.mapMarkers || [];
-    skipInfoWindow = skipInfoWindow || false;
+        // Hide the graceful-fallback HTML list; map will propably work now.
+        // Map-container is not hidden by default in case of graceful-fallback.
+        if (typeof commonMapSettings.showRawLocations === 'undefined') {
+          mapWrapper.find('.geolocation-common-map-locations').hide();
+        }
+        else if (!commonMapSettings.showRawLocations) {
+          mapWrapper.find('.geolocation-common-map-locations').hide();
+        }
 
-    if (typeof map.settings.google_map_settings.marker_icon_path === 'string') {
-      if (typeof markerSettings.icon === 'undefined') {
-        markerSettings.icon = map.settings.google_map_settings.marker_icon_path;
-      }
-    }
+        /**
+         * @type {GeolocationMap}
+         */
+        var geolocationMap = {};
+
+        geolocationMap.id = mapId;
+
+        /*
+         * Check for map already created (i.e. after AJAX)
+         */
+        if (typeof Drupal.geolocation.maps !== 'undefined') {
+          $.each(Drupal.geolocation.maps, function (index, map) {
+            if (typeof map.container !== 'undefined') {
+              if (map.container.is(mapWrapper.find('.geolocation-common-map-container'))) {
+                geolocationMap = map;
+              }
+            }
+          });
+        }
 
-    // Add the marker to the map.
-    /** @type {GoogleMarker} */
-    var currentMarker = new google.maps.Marker(markerSettings);
+        /*
+         * Update existing map, depending on present data-attribute settings.
+         */
+        if (typeof geolocationMap.googleMap !== 'undefined') {
+          if (mapWrapper.data('centre-lat') && mapWrapper.data('centre-lng')) {
+            var newCenter = new google.maps.LatLng(
+              mapWrapper.data('centre-lat'),
+              mapWrapper.data('centre-lng')
+            );
+
+            if (!geolocationMap.googleMap.getCenter().equals(newCenter)) {
+              skipMapIdleEventHandler = true;
+              geolocationMap.googleMap.setCenter(newCenter);
+            }
+          }
+          else if (
+            mapWrapper.data('centre-lat-north-east')
+            && mapWrapper.data('centre-lng-north-east')
+            && mapWrapper.data('centre-lat-south-west')
+            && mapWrapper.data('centre-lng-south-west')
+          ) {
+            var newBounds = {
+              north: mapWrapper.data('centre-lat-north-east'),
+              east: mapWrapper.data('centre-lng-north-east'),
+              south: mapWrapper.data('centre-lat-south-west'),
+              west: mapWrapper.data('centre-lng-south-west')
+            };
+
+            if (!geolocationMap.googleMap.getBounds().equals(newBounds)) {
+              skipMapIdleEventHandler = true;
+              geolocationMap.googleMap.fitBounds(newBounds);
+            }
+          }
+        }
+
+        /*
+         * Instantiate new map.
+         */
+        else {
+          geolocationMap.settings = {};
+          geolocationMap.settings.google_map_settings = commonMapSettings.settings.google_map_settings;
+
+          geolocationMap.container = mapWrapper.find('.geolocation-common-map-container').first();
+          geolocationMap.container.show();
+
+          if (
+            mapWrapper.data('centre-lat')
+            && mapWrapper.data('centre-lng')
+          ) {
+            geolocationMap.lat = mapWrapper.data('centre-lat');
+            geolocationMap.lng = mapWrapper.data('centre-lng');
+
+            skipMapIdleEventHandler = true;
+            geolocationMap.googleMap = Drupal.geolocation.addMap(geolocationMap);
+          }
+          else if (
+            mapWrapper.data('centre-lat-north-east')
+            && mapWrapper.data('centre-lng-north-east')
+            && mapWrapper.data('centre-lat-south-west')
+            && mapWrapper.data('centre-lng-south-west')
+          ) {
+            var centerBounds = {
+              north: mapWrapper.data('centre-lat-north-east'),
+              east: mapWrapper.data('centre-lng-north-east'),
+              south: mapWrapper.data('centre-lat-south-west'),
+              west: mapWrapper.data('centre-lng-south-west')
+            };
+
+            geolocationMap.lat = geolocationMap.lng = 0;
+            skipMapIdleEventHandler = true;
+            geolocationMap.googleMap = Drupal.geolocation.addMap(geolocationMap);
+
+            skipMapIdleEventHandler = true;
+            geolocationMap.googleMap.fitBounds(centerBounds);
+          }
+          else {
+            geolocationMap.lat = geolocationMap.lng = 0;
+
+            skipMapIdleEventHandler = true;
+            geolocationMap.googleMap = Drupal.geolocation.addMap(geolocationMap);
+          }
+        }
 
-    if (skipInfoWindow !== true) {
+        /**
+         * Dynamic map handling aka "AirBnB mode".
+         */
+        if (
+          typeof commonMapSettings.dynamic_map !== 'undefined'
+          && commonMapSettings.dynamic_map.enable
+        ) {
+
+          /**
+           * Update the view depending on dynamic map settings and capability.
+           *
+           * One of several states might occur now. Possible state depends on whether:
+           * - view using AJAX is enabled
+           * - map view is the containing (page) view or an attachment
+           * - the exposed form is present and contains the boundary filter
+           * - map settings are consistent
+           *
+           * Given these factors, map boundary changes can be handled in one of three ways:
+           * - trigger the views AJAX "RefreshView" command
+           * - trigger the exposed form causing a regular POST reload
+           * - fully reload the website
+           *
+           * These possibilities are ordered by UX preference.
+           *
+           * @param {CommonMapUpdateSettings} dynamic_map_settings
+           *   The dynamic map settings to update the map.
+           */
+          if (typeof geolocationMap.updateDrupalView === 'undefined') {
+            geolocationMap.updateDrupalView = function (dynamic_map_settings) {
+              // Make sure to load current form DOM element, which will change after every AJAX operation.
+              var exposedForm = $('form#views-exposed-form-' + dynamic_map_settings.update_view_id.replace(/_/g, '-') + '-' + dynamic_map_settings.update_view_display_id.replace(/_/g, '-'));
+
+              var currentBounds = geolocationMap.googleMap.getBounds();
+              var update_path = '';
+
+              if (
+                typeof dynamic_map_settings.boundary_filter !== 'undefined'
+              ) {
+                if (exposedForm.length) {
+                  exposedForm.find('input[name="' + dynamic_map_settings.parameter_identifier + '[lat_north_east]"]').val(currentBounds.getNorthEast().lat());
+                  exposedForm.find('input[name="' + dynamic_map_settings.parameter_identifier + '[lng_north_east]"]').val(currentBounds.getNorthEast().lng());
+                  exposedForm.find('input[name="' + dynamic_map_settings.parameter_identifier + '[lat_south_west]"]').val(currentBounds.getSouthWest().lat());
+                  exposedForm.find('input[name="' + dynamic_map_settings.parameter_identifier + '[lng_south_west]"]').val(currentBounds.getSouthWest().lng());
+
+                  $('input[type=submit], input[type=image], button[type=submit]', exposedForm).not('[data-drupal-selector=edit-reset]').trigger('click');
+                }
+                // No AJAX, no form, just enforce a page reload with GET parameters set.
+                else {
+                  if (window.location.search.length) {
+                    update_path = window.location.search + '&';
+                  }
+                  else {
+                    update_path = '?';
+                  }
+                  update_path += dynamic_map_settings.parameter_identifier + '[lat_north_east]=' + currentBounds.getNorthEast().lat();
+                  update_path += '&' + dynamic_map_settings.parameter_identifier + '[lng_north_east]=' + currentBounds.getNorthEast().lng();
+                  update_path += '&' + dynamic_map_settings.parameter_identifier + '[lat_south_west]=' + currentBounds.getSouthWest().lat();
+                  update_path += '&' + dynamic_map_settings.parameter_identifier + '[lng_south_west]=' + currentBounds.getSouthWest().lng();
+
+                  window.location = update_path;
+                }
+              }
+            };
+          }
 
-      // Set the info popup text.
-      var currentInfoWindow = new google.maps.InfoWindow({
-        content: markerSettings.infoWindowContent,
-        disableAutoPan: map.settings.google_map_settings.disableAutoPan
-      });
+          if (mapWrapper.data('geolocationAjaxProcessed') !== 1) {
+            var geolocationMapIdleTimer;
+            geolocationMap.googleMap.addListener('idle', function () {
+              if (skipMapIdleEventHandler === true) {
+                skipMapIdleEventHandler = false;
+                return;
+              }
+              clearTimeout(geolocationMapIdleTimer);
+              geolocationMapIdleTimer = setTimeout(function () {
+                geolocationMap.updateDrupalView(commonMapSettings.dynamic_map);
+              }, commonMapSettings.dynamic_map.views_refresh_delay);
+            });
+          }
+        }
 
-      currentMarker.addListener('click', function () {
-        if (markerSettings.infoWindowSolitary) {
-          if (typeof map.infoWindow !== 'undefined') {
-            map.infoWindow.close();
+        /**
+         * Client location handling.
+         */
+        if (typeof mapWrapper.data('clientlocation') !== 'undefined' && !mapWrapper.hasClass('clientlocation-processed')) {
+          mapWrapper.addClass('clientlocation-processed');
+          if (
+            mapWrapper.data('geolocationAjaxProcessed') !== 1
+            && navigator.geolocation
+            && typeof commonMapSettings.client_location !== 'undefined'
+            && commonMapSettings.client_location.enable === true
+          ) {
+            navigator.geolocation.getCurrentPosition(function (position) {
+              mapWrapper.data('centre-lat', position.coords.latitude);
+              mapWrapper.data('centre-lng', position.coords.longitude);
+
+              var newLocation = new google.maps.LatLng(parseFloat(position.coords.latitude), parseFloat(position.coords.longitude));
+
+              skipMapIdleEventHandler = true;
+              geolocationMap.googleMap.setCenter(newLocation);
+              if (skipMapIdleEventHandler !== true) {
+                skipMapIdleEventHandler = true;
+              }
+
+              geolocationMap.googleMap.setZoom(geolocationMap.settings.google_map_settings.zoom);
+
+              Drupal.geolocation.drawAccuracyIndicator(newLocation, parseInt(position.coords.accuracy), geolocationMap.googleMap);
+
+              if (
+                typeof commonMapSettings.client_location.update_map !== 'undefined'
+                && commonMapSettings.client_location.update_map === true
+                && typeof commonMapSettings.dynamic_map !== 'undefined'
+              ) {
+                skipMapIdleEventHandler = true;
+                geolocationMap.updateDrupalView(commonMapSettings.dynamic_map);
+              }
+            });
           }
-          map.infoWindow = currentInfoWindow;
         }
-        currentInfoWindow.open(map.googleMap, currentMarker);
-      });
 
-      if (map.settings.google_map_settings.info_auto_display) {
-        google.maps.event.addListenerOnce(map.googleMap, 'tilesloaded', function () {
-          google.maps.event.trigger(currentMarker, 'click');
+        /**
+         * Result handling.
+         */
+          // A Google Maps API tool to re-center the map on its content.
+        var bounds = new google.maps.LatLngBounds();
+        Drupal.geolocation.removeMapMarker(geolocationMap);
+
+        /*
+         * Add the locations to the map.
+         */
+        mapWrapper.find('.geolocation-common-map-locations .geolocation').each(function (key, location) {
+
+          /** @type {jQuery} */
+          location = $(location);
+          var position = new google.maps.LatLng(parseFloat(location.data('lat')), parseFloat(location.data('lng')));
+
+          bounds.extend(position);
+
+          /**
+           * @type {GoogleMarkerSettings}
+           */
+          var markerConfig = {
+            position: position,
+            map: geolocationMap.googleMap,
+            title: location.children('.location-title').html(),
+            infoWindowContent: location.html(),
+            infoWindowSolitary: true,
+            dvanced: advanced,
+            snazzy: snazzy
+          };
+
+          if (typeof location.data('icon') !== 'undefined') {
+            markerConfig.icon = location.data('icon');
+          }
+
+          if (typeof location.data('markerLabel') !== 'undefined') {
+            markerConfig.label = location.data('markerLabel').toString();
+          }
+
+          var skipInfoWindow = false;
+          if (commonMapSettings.markerScrollToResult === true) {
+            skipInfoWindow = true;
+          }
+
+          var marker = Drupal.geolocation.setMapMarker(geolocationMap, markerConfig, skipInfoWindow);
+
+          marker.addListener('click', function () {
+            if (commonMapSettings.markerScrollToResult === true) {
+              var target = $('[data-location-id="' + location.data('location-id') + '"]:visible').first();
+
+              // Alternatively select by class.
+              if (target.length === 0) {
+                target = $('.geolocation-location-id-' + location.data('location-id') + ':visible').first();
+              }
+
+              if (target.length === 1) {
+                $('html, body').animate({
+                  scrollTop: target.offset().top
+                }, 'slow');
+              }
+            }
+          });
         });
-      }
-    }
 
-    map.mapMarkers.push(currentMarker);
+        /**
+         * Context popup handling.
+         */
+        if (
+          typeof commonMapSettings.contextPopupContent !== 'undefined'
+          && commonMapSettings.contextPopupContent.enable
+        ) {
+
+          /** @type {jQuery} */
+          var contextContainer = jQuery('<div class="geolocation-context-popup"></div>');
+          contextContainer.hide();
+          contextContainer.appendTo(geolocationMap.container);
+
+          /**
+           * Gets the default settings for the Google Map.
+           *
+           * @param {GoogleMapLatLng} latLng - Coordinates.
+           * @return {GoogleMapPoint} - Pixel offset against top left corner of map container.
+           */
+          geolocationMap.googleMap.fromLatLngToPixel = function (latLng) {
+            var numTiles = 1 << geolocationMap.googleMap.getZoom();
+            var projection = geolocationMap.googleMap.getProjection();
+            var worldCoordinate = projection.fromLatLngToPoint(latLng);
+            var pixelCoordinate = new google.maps.Point(
+              worldCoordinate.x * numTiles,
+              worldCoordinate.y * numTiles);
+
+            var topLeft = new google.maps.LatLng(
+              geolocationMap.googleMap.getBounds().getNorthEast().lat(),
+              geolocationMap.googleMap.getBounds().getSouthWest().lng()
+            );
+
+            var topLeftWorldCoordinate = projection.fromLatLngToPoint(topLeft);
+            var topLeftPixelCoordinate = new google.maps.Point(
+              topLeftWorldCoordinate.x * numTiles,
+              topLeftWorldCoordinate.y * numTiles);
+
+            return new google.maps.Point(
+              pixelCoordinate.x - topLeftPixelCoordinate.x,
+              pixelCoordinate.y - topLeftPixelCoordinate.y
+            );
+          };
+
+          google.maps.event.addListener(geolocationMap.googleMap, 'rightclick', function (event) {
+            var content = Drupal.formatString(commonMapSettings.contextPopupContent.content, {
+              '@lat': event.latLng.lat(),
+              '@lng': event.latLng.lng()
+            });
+
+            contextContainer.html(content);
+
+            if (content.length > 0) {
+              var pos = geolocationMap.googleMap.fromLatLngToPixel(event.latLng);
+              contextContainer.show();
+              contextContainer.css('left', pos.x);
+              contextContainer.css('top', pos.y);
+            }
+          });
 
-    return currentMarker;
-  };
+          google.maps.event.addListener(geolocationMap.googleMap, 'click', function (event) {
+            if (typeof contextContainer !== 'undefined') {
+              contextContainer.hide();
+            }
+          });
+        }
 
-  /**
-   * Remove marker(s) from map.
-   *
-   * @param {GeolocationMap} map - The settings object that contains all of the necessary metadata for this map.
-   */
-  Drupal.geolocation.removeMapMarker = function (map) {
-    map.mapMarkers = map.mapMarkers || [];
+        /**
+         * MarkerClusterer handling.
+         */
+        if (
+          typeof commonMapSettings.markerClusterer !== 'undefined'
+          && commonMapSettings.markerClusterer.enable
+          && typeof MarkerClusterer !== 'undefined'
+        ) {
 
-    $.each(
-      map.mapMarkers,
+          /* global MarkerClusterer */
 
-      /**
-       * @param {integer} index - Current index.
-       * @param {GoogleMarker} item - Current marker.
-       */
-      function (index, item) {
-        item.setMap(null);
+          var imagePath = '';
+          if (commonMapSettings.markerClusterer.imagePath) {
+            imagePath = commonMapSettings.markerClusterer.imagePath;
+          }
+          else {
+            imagePath = 'https://cdn.rawgit.com/googlemaps/js-marker-clusterer/gh-pages/images/m';
+          }
+
+          var markerClustererStyles = '';
+          if (typeof commonMapSettings.markerClusterer.styles !== 'undefined') {
+            markerClustererStyles = commonMapSettings.markerClusterer.styles;
+          }
+
+          geolocationMap.markerClusterer = new MarkerClusterer(
+            geolocationMap.googleMap,
+            geolocationMap.mapMarkers,
+            {
+              zoomOnClick: !advanced,
+              averageCenter: true,
+              imagePath: imagePath,
+              styles: [markerClustererStyles]
+            }
+          );
+
+          // Advanced clustering.
+          if (advanced) {
+            geolocationMap.markerClusterer.setCalculator(function (markers, numStyles) {
+              var index = 0, count = markers.length, dv = count, result = {};
+              while (dv > 0) {
+                dv = parseInt(dv - 5, 10);
+                index++;
+              }
+
+              index = Math.min(index, numStyles);
+
+              var custom_id = markers[0].position.lat() + '|' + markers[0].position.lng();
+
+              result = {
+                text: '<span data-cluster-id="' + custom_id + '">' + count + '<span/>',
+                index: index
+              };
+
+              return result;
+            });
+
+            // Bind click on cluster marker.
+            google.maps.event.addListener(geolocationMap.markerClusterer, 'clusterclick', function (cluster) {
+
+              // Revert to default all clusters icons before opening new one.
+              $.each(geolocationMap.markerClusterer.clusters_, function (i, v) {
+                Drupal.geolocation.geolocationAdjustClusterIcon(v);
+              });
+
+              // Changed opened cluster icon.
+              Drupal.geolocation.geolocationAdjustClusterIcon(cluster, 0);
+
+              var markers = cluster.markers_;
+              var markers_count = markers.length;
+
+              if (markers_count) {
+                // If there are more than "zoom_at" items in cluster
+                // or if we have not reached max zoom.
+                if (!cluster.equal && (geolocationMap.googleMap.zoom < geolocationMap.googleMap.maxZoom)) {
+                  geolocationMap.googleMap.fitBounds(cluster.getBounds());
+                }
+                else {
+                  // Get first marker in the cluster.
+                  var firstMarker = markers[0];
+
+                  if (firstMarker) {
+                    var $wrapper = $('<div/>');
+
+                    var $container = $('<div/>')
+                      .addClass('geolocation-info-contrainer')
+                      .appendTo($wrapper);
+
+                    var $ul = $('<ul/>')
+                      .addClass('geolocation-info-ul')
+                      .appendTo($container);
+
+                    $.each(markers, function (index, marker) {
+                      $('<li/>')
+                        .addClass('geolocation-info-li')
+                        .addClass(index == 0 ? 'geolocation-info-li-active' : '')
+                        .attr('data-geolocation-index', index + 1)
+                        .html(marker.infoWindowContent)
+                        .appendTo($ul);
+                    });
+
+                    // Pager counter and controls.
+                    var $pager = $('<div/>')
+                      .addClass('geolocation-pager')
+                      .appendTo($container);
+
+                    $('<a/>')
+                      .addClass('geolocation-pager-prev')
+                      .text('<')
+                      .attr('href', '#')
+                      .appendTo($pager);
+
+                    var page_counters = $('<span/>')
+                      .addClass('geolocation-pager-counters')
+                      .appendTo($pager);
+
+                    $('<span/>').addClass('geolocation-pager-first')
+                      .text('1')
+                      .appendTo(page_counters);
+
+                    $('<span/>').addClass('geolocation-pager-divider')
+                      .text('/')
+                      .appendTo(page_counters);
+
+                    $('<span/>').addClass('geolocation-pager-total')
+                      .text(markers_count)
+                      .appendTo(page_counters);
+
+                    $('<a/>')
+                      .addClass('geolocation-pager-next')
+                      .text('>')
+                      .attr('href', '#')
+                      .appendTo($pager);
+
+                    var position = new google.maps.LatLng(cluster.center_.lat(), cluster.center_.lng());
+                    var autopan = geolocationMap.settings.google_map_settings.disableAutoPan;
+
+                    if (snazzy) {
+                      var infoWindow = new SnazzyInfoWindow({
+                        content: $wrapper.html(),
+                        panOnOpen: !autopan,
+                        wrapperClass: 'geolocation-info-window',
+                        map: geolocationMap.googleMap,
+                        position: position,
+                        offset: {
+                          top: '-57px'
+                        },
+                        callbacks: {
+                          beforeOpen: function () {},
+                          open: function () {},
+                          afterOpen: function () {
+                            Drupal.geolocation.adjustInside(cluster);
+                            Drupal.behaviors.oktoproMapTabs.attach();
+                          },
+                          beforeClose: function () {},
+                          close: function () {
+                            Drupal.geolocation.geolocationAdjustClusterIcon(cluster);
+                          },
+                          afterClose: function () {}
+                        }
+                      });
+
+                      if (typeof geolocationMap.infoWindow !== 'undefined') {
+                        geolocationMap.infoWindow.destroy();
+                      }
+
+                      geolocationMap.infoWindow = infoWindow;
+
+                      infoWindow.open();
+                    }
+                    else {
+                      infoWindow = new google.maps.InfoWindow({
+                        content: $wrapper.html(),
+                        disableAutoPan: autopan,
+                        position: position
+                      });
+
+                      // Revert cluster icon after popup closed.
+                      google.maps.event.addListener(infoWindow, "closeclick", function () {
+                        Drupal.geolocation.geolocationAdjustClusterIcon(cluster);
+                      });
+
+                      // Close all info windows.
+                      if (firstMarker.infoWindowSolitary) {
+                        if (typeof geolocationMap.googleMap.infoWindow !== 'undefined') {
+                          geolocationMap.googleMap.infoWindow.close();
+                        }
+                        geolocationMap.googleMap.infoWindow = infoWindow;
+                      }
+
+                      // Open info window.
+                      infoWindow.open(geolocationMap.googleMap);
+                      Drupal.geolocation.adjustInside(cluster);
+                    }
+                  }
+                }
+              }
+            });
+          }
+        }
+
+        if (mapWrapper.data('fitbounds') === 1) {
+          // Fit map center and zoom to all currently loaded markers.
+          skipMapIdleEventHandler = true;
+          geolocationMap.googleMap.fitBounds(bounds);
+        }
       }
     );
-    map.mapMarkers = [];
-  };
+  }
 
   /**
-   * Draw a circle indicating accuracy and slowly fade it out.
+   * Insert updated map contents into the document.
+   *
+   * ATTENTION: This is a straight ripoff from misc/ajax.js ~line 1017 insert() function.
+   * Please read all code commentary there first!
    *
-   * @param {GoogleMapLatLng} location - A location (latLng) object from Google Maps API.
-   * @param {int} accuracy - Accuracy in meter.
-   * @param {GoogleMap} map - Map to draw on.
+   * @param {Drupal.Ajax} ajax
+   *   {@link Drupal.Ajax} object created by {@link Drupal.ajax}.
+   * @param {object} response
+   *   The response from the Ajax request.
+   * @param {string} response.data
+   *   The data to use with the jQuery method.
+   * @param {string} [response.method]
+   *   The jQuery DOM manipulation method to be used.
+   * @param {string} [response.selector]
+   *   A optional jQuery selector string.
+   * @param {object} [response.settings]
+   *   An optional array of settings that will be used.
+   * @param {number} [status]
+   *   The XMLHttpRequest status.
    */
-  Drupal.geolocation.drawAccuracyIndicator = function (location, accuracy, map) {
-
-    // Draw a circle representing the accuracy radius of HTML5 geolocation.
-    var circle = new google.maps.Circle({
-      center: location,
-      radius: accuracy,
-      map: map,
-      fillColor: '#4285F4',
-      fillOpacity: 0.5,
-      strokeColor: '#4285F4',
-      strokeOpacity: 1,
-      clickable: false
-    });
+  Drupal.AjaxCommands.prototype.geolocationCommonMapsUpdate = function (ajax, response, status) {
+    // See function comment for code origin first before any changes!
+    var $wrapper = response.selector ? $(response.selector) : $(ajax.wrapper);
+    var settings = response.settings || ajax.settings || drupalSettings;
 
-    // Set the zoom level to the accuracy circle's size.
-    map.fitBounds(circle.getBounds());
+    var $new_content_wrapped = $('<div></div>').html(response.data);
+    var $new_content = $new_content_wrapped.contents();
+
+    if ($new_content.length !== 1 || $new_content.get(0).nodeType !== 1) {
+      $new_content = $new_content.parent();
+    }
 
-    // Fade circle away.
-    setInterval(fadeCityCircles, 100);
+    Drupal.detachBehaviors($wrapper.get(0), settings);
 
-    function fadeCityCircles() {
-      var fillOpacity = circle.get('fillOpacity');
-      fillOpacity -= 0.02;
+    // Retain existing map if possible, to avoid jumping and improve UX.
+    if (
+      $new_content.find('.geolocation-common-map-container').length > 0
+      && $wrapper.find('.geolocation-common-map-container').length > 0
+    ) {
+      var detachedMap = $wrapper.find('.geolocation-common-map-container').first().detach();
+      $new_content.find('.geolocation-common-map-container').first().replaceWith(detachedMap);
+      $new_content.find('.geolocation-common-map').data('geolocation-ajax-processed', 1);
+    }
 
-      var strokeOpacity = circle.get('strokeOpacity');
-      strokeOpacity -= 0.04;
+    $wrapper.replaceWith($new_content);
 
-      if (
-        strokeOpacity > 0
-        && fillOpacity > 0
-      ) {
-        circle.setOptions({fillOpacity: fillOpacity, strokeOpacity: strokeOpacity});
-      }
-      else {
-        circle.setMap(null);
-      }
+    // Attach all JavaScript behaviors to the new content, if it was
+    // successfully added to the page, this if statement allows
+    // `#ajax['wrapper']` to be optional.
+    if ($new_content.parents('html').length > 0) {
+      // Apply any settings from the returned JSON if available.
+      Drupal.attachBehaviors($new_content.get(0), settings);
     }
   };
 
   /**
-   * Provides the callback that is called when map is fully loaded.
+   * Convert inner content of popup into pager.
    *
-   * @param {GeolocationMap} map - fully loaded map
-   * @param {string} mapId - Source ID.
+   * @param cluster
    */
-  Drupal.geolocation.mapLoadedCallback = function (map, mapId) {
-    Drupal.geolocation.mapLoadedCallbacks = Drupal.geolocation.mapLoadedCallbacks || [];
-    $.each(Drupal.geolocation.mapLoadedCallbacks, function (index, callbackContainer) {
-      if (callbackContainer.mapId === mapId) {
-        callbackContainer.callback(map);
-      }
+  Drupal.geolocation.adjustInside = function (cluster) {
+    // Adjust items and wrapper size.
+    var width = 0;
+    var total_width = 0;
+    var height = 0;
+    var $items = $('.geolocation-info-ul li.geolocation-info-li');
+
+    $items.each(function () {
+      var this_width = $(this).width();
+      var this_height = $(this).height();
+
+      width = this_width > width ? this_width : width;
+      // Overflow-hidden wrapper width.
+      $('.geolocation-info-contrainer').width(width);
+      height = this_height > height ? this_height : height;
+
+      total_width = parseFloat(total_width) + parseFloat(width);
     });
-  };
 
-  /**
-   * Adds a callback that will be called when map is fully loaded.
-   *
-   * @param {geolocationMapLoadedCallback} callback - The callback
-   * @param {string} mapId - Map ID.
-   */
-  Drupal.geolocation.addMapLoadedCallback = function (callback, mapId) {
-    if (typeof mapId === 'undefined') {
-      return;
-    }
-    Drupal.geolocation.mapLoadedCallbacks = Drupal.geolocation.mapLoadedCallbacks || [];
-    Drupal.geolocation.mapLoadedCallbacks.push({callback: callback, mapId: mapId});
-  };
+    // Overflow-hidden wrapper width.
+    $('.geolocation-info-contrainer').width(width);
 
-  /**
-   * Remove a callback that will be called when map is fully loaded.
-   *
-   * @param {string} mapId - Identify the source
-   */
-  Drupal.geolocation.removeMapLoadedCallback = function (mapId) {
-    Drupal.geolocation.mapLoadedCallbacks = Drupal.geolocation.geocoder.resultCallbacks || [];
-    $.each(Drupal.geolocation.mapLoadedCallbacks, function (index, callback) {
-      if (callback.mapId === mapId) {
-        Drupal.geolocation.mapLoadedCallbacks.splice(index, 1);
+    // Pager items size.
+    $items.width(width).height(height)
+      .css('display', 'inline-block');
+
+    // Ul size.
+    $('.geolocation-info-ul')
+      .width(total_width)
+      .height(height);
+
+    // Pagination function.
+    var geolocationPagination = function (direction) {
+      var $active_item = $('li.geolocation-info-li-active');
+      var active = $active_item.attr('data-geolocation-index');
+      active = parseInt(active);
+
+      var total = $('.geolocation-pager-total').text();
+      total = parseInt(total);
+
+      if (direction == 'next' ? active < total : active > 1) {
+        var next = direction == 'next' ? active + 1 : active - 1;
+
+        $active_item.removeClass('geolocation-info-li-active');
+
+        $('li[data-geolocation-index="' + next + '"]')
+          .addClass('geolocation-info-li-active');
+
+        $('.geolocation-pager-first').text(next);
+
+        var left_skip = (next - 1) * width;
+        $('.geolocation-info-ul').css('left', -left_skip);
+
+        // Change the cluster icon.
+        Drupal.geolocation
+          .geolocationAdjustClusterIcon(cluster, next - 1);
       }
+    };
+
+    $('.geolocation-pager-next').click(function (e) {
+      e.preventDefault();
+      geolocationPagination('next');
+    });
+
+    $('.geolocation-pager-prev').click(function (e) {
+      e.preventDefault();
+      geolocationPagination('prev');
     });
   };
 
-})(jQuery, _, Drupal, drupalSettings);
+})(jQuery, window, Drupal, drupalSettings);
diff --git a/js/markerclusterer.js b/js/markerclusterer.js
new file mode 100644
index 0000000..796bf77
--- /dev/null
+++ b/js/markerclusterer.js
@@ -0,0 +1,1354 @@
+// ==ClosureCompiler==
+// @compilation_level ADVANCED_OPTIMIZATIONS
+// @externs_url https://raw.githubusercontent.com/google/closure-compiler/master/contrib/externs/maps/google_maps_api_v3.js
+// ==/ClosureCompiler==
+
+/**
+ * @name MarkerClusterer for Google Maps v3
+ * @version version 1.0
+ * @author Luke Mahe
+ * @fileoverview
+ * The library creates and manages per-zoom-level clusters for large amounts of
+ * markers.
+ * <br/>
+ * This is a v3 implementation of the
+ * <a href="http://gmaps-utility-library-dev.googlecode.com/svn/tags/markerclusterer/"
+ * >v2 MarkerClusterer</a>.
+ */
+
+/**
+ * @license
+ * Copyright 2010 Google Inc. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+
+/**
+ * A Marker Clusterer that clusters markers.
+ *
+ * @param {google.maps.Map} map The Google map to attach to.
+ * @param {Array.<google.maps.Marker>=} opt_markers Optional markers to add to
+ *   the cluster.
+ * @param {Object=} opt_options support the following options:
+ *     'gridSize': (number) The grid size of a cluster in pixels.
+ *     'maxZoom': (number) The maximum zoom level that a marker can be part of a
+ *                cluster.
+ *     'zoomOnClick': (boolean) Whether the default behaviour of clicking on a
+ *                    cluster is to zoom into it.
+ *     'averageCenter': (boolean) Whether the center of each cluster should be
+ *                      the average of all markers in the cluster.
+ *     'minimumClusterSize': (number) The minimum number of markers to be in a
+ *                           cluster before the markers are hidden and a count
+ *                           is shown.
+ *     'styles': (object) An object that has style properties:
+ *       'url': (string) The image url.
+ *       'height': (number) The image height.
+ *       'width': (number) The image width.
+ *       'anchor': (Array) The anchor position of the label text.
+ *       'textColor': (string) The text color.
+ *       'textSize': (number) The text size.
+ *       'backgroundPosition': (string) The position of the backgound x, y.
+ *       'iconAnchor': (Array) The anchor position of the icon x, y.
+ * @constructor
+ * @extends google.maps.OverlayView
+ */
+function MarkerClusterer(map, opt_markers, opt_options) {
+  // MarkerClusterer implements google.maps.OverlayView interface. We use the
+  // extend function to extend MarkerClusterer with google.maps.OverlayView
+  // because it might not always be available when the code is defined so we
+  // look for it at the last possible moment. If it doesn't exist now then
+  // there is no point going ahead :)
+  this.extend(MarkerClusterer, google.maps.OverlayView);
+  this.map_ = map;
+
+  /**
+   * @type {Array.<google.maps.Marker>}
+   * @private
+   */
+  this.markers_ = [];
+
+  /**
+   *  @type {Array.<Cluster>}
+   */
+  this.clusters_ = [];
+
+  this.sizes = [53, 56, 66, 78, 90];
+
+  /**
+   * @private
+   */
+  this.styles_ = [];
+
+  /**
+   * @type {boolean}
+   * @private
+   */
+  this.ready_ = false;
+
+  var options = opt_options || {};
+
+  /**
+   * @type {number}
+   * @private
+   */
+  this.gridSize_ = options['gridSize'] || 60;
+
+  /**
+   * @private
+   */
+  this.minClusterSize_ = options['minimumClusterSize'] || 2;
+
+
+  /**
+   * @type {?number}
+   * @private
+   */
+  this.maxZoom_ = options['maxZoom'] || null;
+
+  this.styles_ = options['styles'] || [];
+
+  /**
+   * @type {string}
+   * @private
+   */
+  this.imagePath_ = options['imagePath'] ||
+    this.MARKER_CLUSTER_IMAGE_PATH_;
+
+  /**
+   * @type {string}
+   * @private
+   */
+  this.imageExtension_ = options['imageExtension'] ||
+    this.MARKER_CLUSTER_IMAGE_EXTENSION_;
+
+  /**
+   * @type {boolean}
+   * @private
+   */
+  this.zoomOnClick_ = true;
+
+  if (options['zoomOnClick'] != undefined) {
+    this.zoomOnClick_ = options['zoomOnClick'];
+  }
+
+  /**
+   * @type {boolean}
+   * @private
+   */
+  this.averageCenter_ = false;
+
+  if (options['averageCenter'] != undefined) {
+    this.averageCenter_ = options['averageCenter'];
+  }
+
+  this.setupStyles_();
+
+  this.setMap(map);
+
+  /**
+   * @type {number}
+   * @private
+   */
+  this.prevZoom_ = this.map_.getZoom();
+
+  // Add the map event listeners
+  var that = this;
+  google.maps.event.addListener(this.map_, 'zoom_changed', function() {
+    var zoom = that.map_.getZoom();
+
+    if (that.prevZoom_ != zoom) {
+      that.prevZoom_ = zoom;
+      that.resetViewport();
+    }
+  });
+
+  google.maps.event.addListener(this.map_, 'idle', function() {
+    that.redraw();
+  });
+
+  // Finally, add the markers
+  if (opt_markers && opt_markers.length) {
+    this.addMarkers(opt_markers, false);
+  }
+}
+
+
+/**
+ * The marker cluster image path.
+ *
+ * @type {string}
+ * @private
+ */
+MarkerClusterer.prototype.MARKER_CLUSTER_IMAGE_PATH_ = '../images/m';
+
+
+/**
+ * The marker cluster image path.
+ *
+ * @type {string}
+ * @private
+ */
+MarkerClusterer.prototype.MARKER_CLUSTER_IMAGE_EXTENSION_ = 'png';
+
+
+/**
+ * Extends a objects prototype by anothers.
+ *
+ * @param {Object} obj1 The object to be extended.
+ * @param {Object} obj2 The object to extend with.
+ * @return {Object} The new extended object.
+ * @ignore
+ */
+MarkerClusterer.prototype.extend = function(obj1, obj2) {
+  return (function(object) {
+    for (var property in object.prototype) {
+      this.prototype[property] = object.prototype[property];
+    }
+    return this;
+  }).apply(obj1, [obj2]);
+};
+
+
+/**
+ * Implementaion of the interface method.
+ * @ignore
+ */
+MarkerClusterer.prototype.onAdd = function() {
+  this.setReady_(true);
+};
+
+/**
+ * Implementaion of the interface method.
+ * @ignore
+ */
+MarkerClusterer.prototype.draw = function() {};
+
+/**
+ * Sets up the styles object.
+ *
+ * @private
+ */
+MarkerClusterer.prototype.setupStyles_ = function() {
+  if (this.styles_.length) {
+    return;
+  }
+
+  for (var i = 0, size; size = this.sizes[i]; i++) {
+    this.styles_.push({
+      url: this.imagePath_ + (i + 1) + '.' + this.imageExtension_,
+      height: size,
+      width: size
+    });
+  }
+};
+
+/**
+ *  Fit the map to the bounds of the markers in the clusterer.
+ */
+MarkerClusterer.prototype.fitMapToMarkers = function() {
+  var markers = this.getMarkers();
+  var bounds = new google.maps.LatLngBounds();
+  for (var i = 0, marker; marker = markers[i]; i++) {
+    bounds.extend(marker.getPosition());
+  }
+
+  this.map_.fitBounds(bounds);
+};
+
+
+/**
+ *  Sets the styles.
+ *
+ *  @param {Object} styles The style to set.
+ */
+MarkerClusterer.prototype.setStyles = function(styles) {
+  this.styles_ = styles;
+};
+
+
+/**
+ *  Gets the styles.
+ *
+ *  @return {Object} The styles object.
+ */
+MarkerClusterer.prototype.getStyles = function() {
+  return this.styles_;
+};
+
+
+/**
+ * Whether zoom on click is set.
+ *
+ * @return {boolean} True if zoomOnClick_ is set.
+ */
+MarkerClusterer.prototype.isZoomOnClick = function() {
+  return this.zoomOnClick_;
+};
+
+/**
+ * Whether average center is set.
+ *
+ * @return {boolean} True if averageCenter_ is set.
+ */
+MarkerClusterer.prototype.isAverageCenter = function() {
+  return this.averageCenter_;
+};
+
+
+/**
+ *  Returns the array of markers in the clusterer.
+ *
+ *  @return {Array.<google.maps.Marker>} The markers.
+ */
+MarkerClusterer.prototype.getMarkers = function() {
+  return this.markers_;
+};
+
+
+/**
+ *  Returns the number of markers in the clusterer
+ *
+ *  @return {Number} The number of markers.
+ */
+MarkerClusterer.prototype.getTotalMarkers = function() {
+  return this.markers_.length;
+};
+
+
+/**
+ *  Sets the max zoom for the clusterer.
+ *
+ *  @param {number} maxZoom The max zoom level.
+ */
+MarkerClusterer.prototype.setMaxZoom = function(maxZoom) {
+  this.maxZoom_ = maxZoom;
+};
+
+
+/**
+ *  Gets the max zoom for the clusterer.
+ *
+ *  @return {number} The max zoom level.
+ */
+MarkerClusterer.prototype.getMaxZoom = function() {
+  return this.maxZoom_;
+};
+
+
+/**
+ *  The function for calculating the cluster icon image.
+ *
+ *  @param {Array.<google.maps.Marker>} markers The markers in the clusterer.
+ *  @param {number} numStyles The number of styles available.
+ *  @return {Object} A object properties: 'text' (string) and 'index' (number).
+ *  @private
+ */
+MarkerClusterer.prototype.calculator_ = function(markers, numStyles) {
+  var index = 0;
+  var count = markers.length;
+  var dv = count;
+  while (dv !== 0) {
+    dv = parseInt(dv / 10, 10);
+    index++;
+  }
+
+  index = Math.min(index, numStyles);
+  return {
+    text: count,
+    index: index
+  };
+};
+
+
+/**
+ * Set the calculator function.
+ *
+ * @param {function(Array, number)} calculator The function to set as the
+ *     calculator. The function should return a object properties:
+ *     'text' (string) and 'index' (number).
+ *
+ */
+MarkerClusterer.prototype.setCalculator = function(calculator) {
+  this.calculator_ = calculator;
+};
+
+
+/**
+ * Get the calculator function.
+ *
+ * @return {function(Array, number)} the calculator function.
+ */
+MarkerClusterer.prototype.getCalculator = function() {
+  return this.calculator_;
+};
+
+
+/**
+ * Add an array of markers to the clusterer.
+ *
+ * @param {Array.<google.maps.Marker>} markers The markers to add.
+ * @param {boolean=} opt_nodraw Whether to redraw the clusters.
+ */
+MarkerClusterer.prototype.addMarkers = function(markers, opt_nodraw) {
+  for (var i = 0, marker; marker = markers[i]; i++) {
+    this.pushMarkerTo_(marker);
+  }
+  if (!opt_nodraw) {
+    this.redraw();
+  }
+};
+
+
+/**
+ * Pushes a marker to the clusterer.
+ *
+ * @param {google.maps.Marker} marker The marker to add.
+ * @private
+ */
+MarkerClusterer.prototype.pushMarkerTo_ = function(marker) {
+  marker.isAdded = false;
+  if (marker['draggable']) {
+    // If the marker is draggable add a listener so we update the clusters on
+    // the drag end.
+    var that = this;
+    google.maps.event.addListener(marker, 'dragend', function() {
+      marker.isAdded = false;
+      that.repaint();
+    });
+  }
+  this.markers_.push(marker);
+};
+
+
+/**
+ * Adds a marker to the clusterer and redraws if needed.
+ *
+ * @param {google.maps.Marker} marker The marker to add.
+ * @param {boolean=} opt_nodraw Whether to redraw the clusters.
+ */
+MarkerClusterer.prototype.addMarker = function(marker, opt_nodraw) {
+  this.pushMarkerTo_(marker);
+  if (!opt_nodraw) {
+    this.redraw();
+  }
+};
+
+
+/**
+ * Removes a marker and returns true if removed, false if not
+ *
+ * @param {google.maps.Marker} marker The marker to remove
+ * @return {boolean} Whether the marker was removed or not
+ * @private
+ */
+MarkerClusterer.prototype.removeMarker_ = function(marker) {
+  var index = -1;
+  if (this.markers_.indexOf) {
+    index = this.markers_.indexOf(marker);
+  } else {
+    for (var i = 0, m; m = this.markers_[i]; i++) {
+      if (m == marker) {
+        index = i;
+        break;
+      }
+    }
+  }
+
+  if (index == -1) {
+    // Marker is not in our list of markers.
+    return false;
+  }
+
+  marker.setMap(null);
+
+  this.markers_.splice(index, 1);
+
+  return true;
+};
+
+
+/**
+ * Remove a marker from the cluster.
+ *
+ * @param {google.maps.Marker} marker The marker to remove.
+ * @param {boolean=} opt_nodraw Optional boolean to force no redraw.
+ * @return {boolean} True if the marker was removed.
+ */
+MarkerClusterer.prototype.removeMarker = function(marker, opt_nodraw) {
+  var removed = this.removeMarker_(marker);
+
+  if (!opt_nodraw && removed) {
+    this.resetViewport();
+    this.redraw();
+    return true;
+  } else {
+    return false;
+  }
+};
+
+
+/**
+ * Removes an array of markers from the cluster.
+ *
+ * @param {Array.<google.maps.Marker>} markers The markers to remove.
+ * @param {boolean=} opt_nodraw Optional boolean to force no redraw.
+ */
+MarkerClusterer.prototype.removeMarkers = function(markers, opt_nodraw) {
+  var removed = false;
+
+  for (var i = 0, marker; marker = markers[i]; i++) {
+    var r = this.removeMarker_(marker);
+    removed = removed || r;
+  }
+
+  if (!opt_nodraw && removed) {
+    this.resetViewport();
+    this.redraw();
+    return true;
+  }
+};
+
+
+/**
+ * Sets the clusterer's ready state.
+ *
+ * @param {boolean} ready The state.
+ * @private
+ */
+MarkerClusterer.prototype.setReady_ = function(ready) {
+  if (!this.ready_) {
+    this.ready_ = ready;
+    this.createClusters_();
+  }
+};
+
+
+/**
+ * Returns the number of clusters in the clusterer.
+ *
+ * @return {number} The number of clusters.
+ */
+MarkerClusterer.prototype.getTotalClusters = function() {
+  return this.clusters_.length;
+};
+
+
+/**
+ * Returns the google map that the clusterer is associated with.
+ *
+ * @return {google.maps.Map} The map.
+ */
+MarkerClusterer.prototype.getMap = function() {
+  return this.map_;
+};
+
+
+/**
+ * Sets the google map that the clusterer is associated with.
+ *
+ * @param {google.maps.Map} map The map.
+ */
+MarkerClusterer.prototype.setMap = function(map) {
+  this.map_ = map;
+};
+
+
+/**
+ * Returns the size of the grid.
+ *
+ * @return {number} The grid size.
+ */
+MarkerClusterer.prototype.getGridSize = function() {
+  return this.gridSize_;
+};
+
+
+/**
+ * Sets the size of the grid.
+ *
+ * @param {number} size The grid size.
+ */
+MarkerClusterer.prototype.setGridSize = function(size) {
+  this.gridSize_ = size;
+};
+
+
+/**
+ * Returns the min cluster size.
+ *
+ * @return {number} The grid size.
+ */
+MarkerClusterer.prototype.getMinClusterSize = function() {
+  return this.minClusterSize_;
+};
+
+/**
+ * Sets the min cluster size.
+ *
+ * @param {number} size The grid size.
+ */
+MarkerClusterer.prototype.setMinClusterSize = function(size) {
+  this.minClusterSize_ = size;
+};
+
+
+/**
+ * Extends a bounds object by the grid size.
+ *
+ * @param {google.maps.LatLngBounds} bounds The bounds to extend.
+ * @return {google.maps.LatLngBounds} The extended bounds.
+ */
+MarkerClusterer.prototype.getExtendedBounds = function(bounds) {
+  var projection = this.getProjection();
+
+  // Turn the bounds into latlng.
+  var tr = new google.maps.LatLng(bounds.getNorthEast().lat(),
+    bounds.getNorthEast().lng());
+  var bl = new google.maps.LatLng(bounds.getSouthWest().lat(),
+    bounds.getSouthWest().lng());
+
+  // Convert the points to pixels and the extend out by the grid size.
+  var trPix = projection.fromLatLngToDivPixel(tr);
+  trPix.x += this.gridSize_;
+  trPix.y -= this.gridSize_;
+
+  var blPix = projection.fromLatLngToDivPixel(bl);
+  blPix.x -= this.gridSize_;
+  blPix.y += this.gridSize_;
+
+  // Convert the pixel points back to LatLng
+  var ne = projection.fromDivPixelToLatLng(trPix);
+  var sw = projection.fromDivPixelToLatLng(blPix);
+
+  // Extend the bounds to contain the new bounds.
+  bounds.extend(ne);
+  bounds.extend(sw);
+
+  return bounds;
+};
+
+
+/**
+ * Determins if a marker is contained in a bounds.
+ *
+ * @param {google.maps.Marker} marker The marker to check.
+ * @param {google.maps.LatLngBounds} bounds The bounds to check against.
+ * @return {boolean} True if the marker is in the bounds.
+ * @private
+ */
+MarkerClusterer.prototype.isMarkerInBounds_ = function(marker, bounds) {
+  return bounds.contains(marker.getPosition());
+};
+
+
+/**
+ * Clears all clusters and markers from the clusterer.
+ */
+MarkerClusterer.prototype.clearMarkers = function() {
+  this.resetViewport(true);
+
+  // Set the markers a empty array.
+  this.markers_ = [];
+};
+
+
+/**
+ * Clears all existing clusters and recreates them.
+ * @param {boolean} opt_hide To also hide the marker.
+ */
+MarkerClusterer.prototype.resetViewport = function(opt_hide) {
+  // Remove all the clusters
+  for (var i = 0, cluster; cluster = this.clusters_[i]; i++) {
+    cluster.remove();
+  }
+
+  // Reset the markers to not be added and to be invisible.
+  for (var i = 0, marker; marker = this.markers_[i]; i++) {
+    marker.isAdded = false;
+    if (opt_hide) {
+      marker.setMap(null);
+    }
+  }
+
+  this.clusters_ = [];
+};
+
+/**
+ *
+ */
+MarkerClusterer.prototype.repaint = function() {
+  var oldClusters = this.clusters_.slice();
+  this.clusters_.length = 0;
+  this.resetViewport();
+  this.redraw();
+
+  // Remove the old clusters.
+  // Do it in a timeout so the other clusters have been drawn first.
+  window.setTimeout(function() {
+    for (var i = 0, cluster; cluster = oldClusters[i]; i++) {
+      cluster.remove();
+    }
+  }, 0);
+};
+
+
+/**
+ * Redraws the clusters.
+ */
+MarkerClusterer.prototype.redraw = function() {
+  this.createClusters_();
+};
+
+
+/**
+ * Calculates the distance between two latlng locations in km.
+ * @see http://www.movable-type.co.uk/scripts/latlong.html
+ *
+ * @param {google.maps.LatLng} p1 The first lat lng point.
+ * @param {google.maps.LatLng} p2 The second lat lng point.
+ * @return {number} The distance between the two points in km.
+ * @private
+ */
+MarkerClusterer.prototype.distanceBetweenPoints_ = function(p1, p2) {
+  if (!p1 || !p2) {
+    return 0;
+  }
+
+  var R = 6371; // Radius of the Earth in km
+  var dLat = (p2.lat() - p1.lat()) * Math.PI / 180;
+  var dLon = (p2.lng() - p1.lng()) * Math.PI / 180;
+  var a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +
+    Math.cos(p1.lat() * Math.PI / 180) * Math.cos(p2.lat() * Math.PI / 180) *
+    Math.sin(dLon / 2) * Math.sin(dLon / 2);
+  var c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
+  var d = R * c;
+  return d;
+};
+
+
+/**
+ * Add a marker to a cluster, or creates a new cluster.
+ *
+ * @param {google.maps.Marker} marker The marker to add.
+ * @private
+ */
+MarkerClusterer.prototype.addToClosestCluster_ = function(marker) {
+  var distance = 40000; // Some large number
+  var clusterToAddTo = null;
+  var pos = marker.getPosition();
+  for (var i = 0, cluster; cluster = this.clusters_[i]; i++) {
+    var center = cluster.getCenter();
+    if (center) {
+      var d = this.distanceBetweenPoints_(center, marker.getPosition());
+      if (d < distance) {
+        distance = d;
+        clusterToAddTo = cluster;
+      }
+    }
+  }
+
+  if (clusterToAddTo && clusterToAddTo.isMarkerInClusterBounds(marker)) {
+    clusterToAddTo.addMarker(marker);
+  } else {
+    var cluster = new Cluster(this);
+    cluster.addMarker(marker);
+    this.clusters_.push(cluster);
+  }
+};
+
+
+/**
+ * Creates the clusters.
+ *
+ * @private
+ */
+MarkerClusterer.prototype.createClusters_ = function() {
+  if (!this.ready_) {
+    return;
+  }
+
+  // Get our current map view bounds.
+  // Create a new bounds object so we don't affect the map.
+  var mapBounds = new google.maps.LatLngBounds(this.map_.getBounds().getSouthWest(),
+    this.map_.getBounds().getNorthEast());
+  var bounds = this.getExtendedBounds(mapBounds);
+
+  for (var i = 0, marker; marker = this.markers_[i]; i++) {
+    if (!marker.isAdded && this.isMarkerInBounds_(marker, bounds)) {
+      this.addToClosestCluster_(marker);
+    }
+  }
+};
+
+
+/**
+ * A cluster that contains markers.
+ *
+ * @param {MarkerClusterer} markerClusterer The markerclusterer that this
+ *     cluster is associated with.
+ * @constructor
+ * @ignore
+ */
+function Cluster(markerClusterer) {
+  this.markerClusterer_ = markerClusterer;
+  this.map_ = markerClusterer.getMap();
+  this.gridSize_ = markerClusterer.getGridSize();
+  this.minClusterSize_ = markerClusterer.getMinClusterSize();
+  this.averageCenter_ = markerClusterer.isAverageCenter();
+  this.center_ = null;
+  this.markers_ = [];
+  this.bounds_ = null;
+  this.clusterIcon_ = new ClusterIcon(this, markerClusterer.getStyles(),
+    markerClusterer.getGridSize());
+}
+
+/**
+ * Determins if a marker is already added to the cluster.
+ *
+ * @param {google.maps.Marker} marker The marker to check.
+ * @return {boolean} True if the marker is already added.
+ */
+Cluster.prototype.isMarkerAlreadyAdded = function(marker) {
+  if (this.markers_.indexOf) {
+    return this.markers_.indexOf(marker) != -1;
+  } else {
+    for (var i = 0, m; m = this.markers_[i]; i++) {
+      if (m == marker) {
+        return true;
+      }
+    }
+  }
+  return false;
+};
+
+
+/**
+ * Add a marker the cluster.
+ *
+ * @param {google.maps.Marker} marker The marker to add.
+ * @return {boolean} True if the marker was added.
+ */
+Cluster.prototype.addMarker = function(marker) {
+  if (this.isMarkerAlreadyAdded(marker)) {
+    return false;
+  }
+
+  if (!this.center_) {
+    this.center_ = marker.getPosition();
+    this.calculateBounds_();
+  } else {
+    if (this.averageCenter_) {
+      var l = this.markers_.length + 1;
+      var lat = (this.center_.lat() * (l-1) + marker.getPosition().lat()) / l;
+      var lng = (this.center_.lng() * (l-1) + marker.getPosition().lng()) / l;
+      this.center_ = new google.maps.LatLng(lat, lng);
+      this.calculateBounds_();
+    }
+  }
+
+  marker.isAdded = true;
+  this.markers_.push(marker);
+
+  var len = this.markers_.length;
+  if (len < this.minClusterSize_ && marker.getMap() != this.map_) {
+    // Min cluster size not reached so show the marker.
+    marker.setMap(this.map_);
+  }
+
+  if (len == this.minClusterSize_) {
+    // Hide the markers that were showing.
+    for (var i = 0; i < len; i++) {
+      this.markers_[i].setMap(null);
+    }
+  }
+
+  if (len >= this.minClusterSize_) {
+    marker.setMap(null);
+  }
+
+  this.updateIcon();
+  return true;
+};
+
+
+/**
+ * Returns the marker clusterer that the cluster is associated with.
+ *
+ * @return {MarkerClusterer} The associated marker clusterer.
+ */
+Cluster.prototype.getMarkerClusterer = function() {
+  return this.markerClusterer_;
+};
+
+
+/**
+ * Returns the bounds of the cluster.
+ *
+ * @return {google.maps.LatLngBounds} the cluster bounds.
+ */
+Cluster.prototype.getBounds = function() {
+  var bounds = new google.maps.LatLngBounds(this.center_, this.center_);
+  var markers = this.getMarkers();
+  for (var i = 0, marker; marker = markers[i]; i++) {
+    bounds.extend(marker.getPosition());
+  }
+  return bounds;
+};
+
+
+/**
+ * Removes the cluster
+ */
+Cluster.prototype.remove = function() {
+  this.clusterIcon_.remove();
+  this.markers_.length = 0;
+  delete this.markers_;
+};
+
+
+/**
+ * Returns the center of the cluster.
+ *
+ * @return {number} The cluster center.
+ */
+Cluster.prototype.getSize = function() {
+  return this.markers_.length;
+};
+
+
+/**
+ * Returns the center of the cluster.
+ *
+ * @return {Array.<google.maps.Marker>} The cluster center.
+ */
+Cluster.prototype.getMarkers = function() {
+  return this.markers_;
+};
+
+
+/**
+ * Returns the center of the cluster.
+ *
+ * @return {google.maps.LatLng} The cluster center.
+ */
+Cluster.prototype.getCenter = function() {
+  return this.center_;
+};
+
+
+/**
+ * Calculated the extended bounds of the cluster with the grid.
+ *
+ * @private
+ */
+Cluster.prototype.calculateBounds_ = function() {
+  var bounds = new google.maps.LatLngBounds(this.center_, this.center_);
+  this.bounds_ = this.markerClusterer_.getExtendedBounds(bounds);
+};
+
+
+/**
+ * Determines if a marker lies in the clusters bounds.
+ *
+ * @param {google.maps.Marker} marker The marker to check.
+ * @return {boolean} True if the marker lies in the bounds.
+ */
+Cluster.prototype.isMarkerInClusterBounds = function(marker) {
+  return this.bounds_.contains(marker.getPosition());
+};
+
+
+/**
+ * Returns the map that the cluster is associated with.
+ *
+ * @return {google.maps.Map} The map.
+ */
+Cluster.prototype.getMap = function() {
+  return this.map_;
+};
+
+
+/**
+ * Updates the cluster icon
+ */
+Cluster.prototype.updateIcon = function() {
+  var zoom = this.map_.getZoom();
+  var mz = this.markerClusterer_.getMaxZoom();
+
+  if (mz && zoom > mz) {
+    // The zoom is greater than our max zoom so show all the markers in cluster.
+    for (var i = 0, marker; marker = this.markers_[i]; i++) {
+      marker.setMap(this.map_);
+    }
+    return;
+  }
+
+  if (this.markers_.length < this.minClusterSize_) {
+    // Min cluster size not yet reached.
+    this.clusterIcon_.hide();
+    return;
+  }
+
+  var numStyles = this.markerClusterer_.getStyles().length;
+  var sums = this.markerClusterer_.getCalculator()(this.markers_, numStyles);
+  this.clusterIcon_.setCenter(this.center_);
+  this.clusterIcon_.setSums(sums);
+  this.clusterIcon_.show();
+};
+
+
+/**
+ * A cluster icon
+ *
+ * @param {Cluster} cluster The cluster to be associated with.
+ * @param {Object} styles An object that has style properties:
+ *     'url': (string) The image url.
+ *     'height': (number) The image height.
+ *     'width': (number) The image width.
+ *     'anchor': (Array) The anchor position of the label text.
+ *     'textColor': (string) The text color.
+ *     'textSize': (number) The text size.
+ *     'backgroundPosition: (string) The background postition x, y.
+ * @param {number=} opt_padding Optional padding to apply to the cluster icon.
+ * @constructor
+ * @extends google.maps.OverlayView
+ * @ignore
+ */
+function ClusterIcon(cluster, styles, opt_padding) {
+  cluster.getMarkerClusterer().extend(ClusterIcon, google.maps.OverlayView);
+
+  this.styles_ = styles;
+  this.padding_ = opt_padding || 0;
+  this.cluster_ = cluster;
+  this.center_ = null;
+  this.map_ = cluster.getMap();
+  this.div_ = null;
+  this.sums_ = null;
+  this.visible_ = false;
+
+  this.setMap(this.map_);
+}
+
+
+/**
+ * Triggers the clusterclick event and zoom's if the option is set.
+ *
+ * @param {google.maps.MouseEvent} event The event to propagate
+ */
+ClusterIcon.prototype.triggerClusterClick = function(event) {
+  var markerClusterer = this.cluster_.getMarkerClusterer();
+
+  // Trigger the clusterclick event.
+  google.maps.event.trigger(markerClusterer, 'clusterclick', this.cluster_, event);
+
+  if (markerClusterer.isZoomOnClick()) {
+    // Zoom into the cluster.
+    this.map_.fitBounds(this.cluster_.getBounds());
+  }
+};
+
+
+/**
+ * Adding the cluster icon to the dom.
+ * @ignore
+ */
+ClusterIcon.prototype.onAdd = function() {
+
+
+
+  this.div_ = document.createElement('DIV');
+  if (this.visible_) {
+    var pos = this.getPosFromLatLng_(this.center_);
+    this.div_.style.cssText = this.createCss(pos);
+    this.div_.innerHTML = this.sums_.text;
+  }
+
+  var panes = this.getPanes();
+  panes.overlayMouseTarget.appendChild(this.div_);
+
+  var that = this;
+  var isDragging = false;
+  google.maps.event.addDomListener(this.div_, 'click', function(event) {
+    // Only perform click when not preceded by a drag
+    if (!isDragging) {
+      that.triggerClusterClick(event);
+    }
+  });
+  google.maps.event.addDomListener(this.div_, 'mousedown', function() {
+    isDragging = false;
+  });
+  google.maps.event.addDomListener(this.div_, 'mousemove', function() {
+    isDragging = true;
+  });
+};
+
+
+/**
+ * Returns the position to place the div dending on the latlng.
+ *
+ * @param {google.maps.LatLng} latlng The position in latlng.
+ * @return {google.maps.Point} The position in pixels.
+ * @private
+ */
+ClusterIcon.prototype.getPosFromLatLng_ = function(latlng) {
+  var pos = this.getProjection().fromLatLngToDivPixel(latlng);
+
+  if (typeof this.iconAnchor_ === 'object' && this.iconAnchor_.length === 2) {
+    pos.x -= this.iconAnchor_[0];
+    pos.y -= this.iconAnchor_[1];
+  } else {
+    pos.x -= parseInt(this.width_ / 2, 10);
+    pos.y -= parseInt(this.height_ / 2, 10);
+  }
+
+  if (!this.cluster_.equal && (this.map.zoom < this.map.maxZoom)) {
+    pos.y = pos.y + 50;
+  }
+
+  return pos;
+};
+
+
+/**
+ * Draw the icon.
+ * @ignore
+ */
+ClusterIcon.prototype.draw = function() {
+  if (this.visible_) {
+    var pos = this.getPosFromLatLng_(this.center_);
+
+    this.div_.style.top = pos.y + 'px';
+    this.div_.style.left = pos.x + 'px';
+  }
+};
+
+
+/**
+ * Hide the icon.
+ */
+ClusterIcon.prototype.hide = function() {
+  if (this.div_) {
+    this.div_.style.display = 'none';
+  }
+  this.visible_ = false;
+};
+
+
+/**
+ * Position and show the icon.
+ */
+ClusterIcon.prototype.show = function() {
+  if (this.div_) {
+    var pos = this.getPosFromLatLng_(this.center_);
+    this.div_.style.cssText = this.createCss(pos);
+    this.div_.style.display = '';
+  }
+  this.visible_ = true;
+};
+
+
+/**
+ * Remove the icon from the map
+ */
+ClusterIcon.prototype.remove = function() {
+  this.setMap(null);
+};
+
+
+/**
+ * Implementation of the onRemove interface.
+ * @ignore
+ */
+ClusterIcon.prototype.onRemove = function() {
+  if (this.div_ && this.div_.parentNode) {
+    this.hide();
+    this.div_.parentNode.removeChild(this.div_);
+    this.div_ = null;
+  }
+};
+
+
+/**
+ * Set the sums of the icon.
+ *
+ * @param {Object} sums The sums containing:
+ *   'text': (string) The text to display in the icon.
+ *   'index': (number) The style index of the icon.
+ */
+ClusterIcon.prototype.setSums = function(sums) {
+  this.sums_ = sums;
+  this.text_ = sums.text;
+  this.index_ = sums.index;
+  if (this.div_) {
+    this.div_.innerHTML = sums.text;
+  }
+
+  this.useStyle();
+};
+
+
+/**
+ * Sets the icon to the the styles.
+ */
+ClusterIcon.prototype.useStyle = function() {
+
+  var index = Math.max(0, this.sums_.index - 1);
+  index = Math.min(this.styles_.length - 1, index);
+  var style = this.styles_[index];
+
+  var inner_markers = this.cluster_.markers_;
+  var last = false;
+  var equal = true;
+
+  jQuery.each(inner_markers, function (j, m) {
+    var curent = new google.maps.LatLng(m.position.lat(), m.position.lng());
+
+    if (last) {
+      if (!curent.equals(last)) {
+        equal = false;
+      }
+    }
+    else {
+      last = curent;
+    }
+  });
+
+  var marker_img = '/themes/custom/oktopro/clusters/blank.png';
+
+  this.cluster_.equal = equal;
+
+  if (equal) {
+    marker_img = '/themes/custom/oktopro/clusters/more.ai.png';
+  }
+
+  this.url_ = marker_img;
+  this.height_ = style['height'];
+  this.width_ = style['width'];
+  this.textColor_ = style['textColor'];
+  this.anchor_ = style['anchor'];
+  this.textSize_ = style['textSize'];
+  this.backgroundPosition_ = style['backgroundPosition'];
+  this.iconAnchor_ = style['iconAnchor'];
+};
+
+
+/**
+ * Sets the center of the icon.
+ *
+ * @param {google.maps.LatLng} center The latlng to set as the center.
+ */
+ClusterIcon.prototype.setCenter = function(center) {
+  this.center_ = center;
+};
+
+
+/**
+ * Create the css text based on the position of the icon.
+ *
+ * @param {google.maps.Point} pos The position.
+ * @return {string} The css style text.
+ */
+ClusterIcon.prototype.createCss = function(pos) {
+  var style = [];
+  style.push('background-image:url(' + this.url_ + ');');
+  var backgroundPosition = this.backgroundPosition_ ? this.backgroundPosition_ : '0 0';
+
+  style.push('background-position:' + backgroundPosition + ';');
+  style.push('background-repeat:no-repeat;');
+
+  if (typeof this.anchor_ === 'object') {
+    if (typeof this.anchor_[0] === 'number' && this.anchor_[0] > 0 &&
+      this.anchor_[0] < this.height_) {
+      style.push('height:' + (this.height_ - this.anchor_[0]) +
+        'px; padding-top:' + this.anchor_[0] + 'px;');
+    } else if (typeof this.anchor_[0] === 'number' && this.anchor_[0] < 0 &&
+      -this.anchor_[0] < this.height_) {
+      style.push('height:' + this.height_ + 'px; line-height:' + (this.height_ + this.anchor_[0]) +
+        'px;');
+    } else {
+      style.push('height:' + this.height_ + 'px; line-height:' + this.height_ +
+        'px;');
+    }
+    if (typeof this.anchor_[1] === 'number' && this.anchor_[1] > 0 &&
+      this.anchor_[1] < this.width_) {
+      style.push('width:' + (this.width_ - this.anchor_[1]) +
+        'px; padding-left:' + this.anchor_[1] + 'px;');
+    } else {
+      style.push('width:' + this.width_ + 'px; text-align:center;');
+    }
+  } else {
+    style.push('height:' + this.height_ + 'px; line-height:' +
+      this.height_ + 'px; width:' + this.width_ + 'px; text-align:center;');
+  }
+
+  var txtColor = this.textColor_ ? this.textColor_ : 'black';
+  var txtSize = this.textSize_ ? this.textSize_ : 11;
+
+  style.push('cursor:pointer; top:' + pos.y + 'px; left:' +
+    pos.x + 'px; color:' + txtColor + '; position:absolute; font-size:' +
+    txtSize + 'px; font-family:Arial,sans-serif; font-weight:bold');
+
+  return style.join('');
+};
+
+
+// Export Symbols for Closure
+// If you are not going to compile with closure then you can remove the
+// code below.
+window['MarkerClusterer'] = MarkerClusterer;
+MarkerClusterer.prototype['addMarker'] = MarkerClusterer.prototype.addMarker;
+MarkerClusterer.prototype['addMarkers'] = MarkerClusterer.prototype.addMarkers;
+MarkerClusterer.prototype['clearMarkers'] =
+  MarkerClusterer.prototype.clearMarkers;
+MarkerClusterer.prototype['fitMapToMarkers'] =
+  MarkerClusterer.prototype.fitMapToMarkers;
+MarkerClusterer.prototype['getCalculator'] =
+  MarkerClusterer.prototype.getCalculator;
+MarkerClusterer.prototype['getGridSize'] =
+  MarkerClusterer.prototype.getGridSize;
+MarkerClusterer.prototype['getExtendedBounds'] =
+  MarkerClusterer.prototype.getExtendedBounds;
+MarkerClusterer.prototype['getMap'] = MarkerClusterer.prototype.getMap;
+MarkerClusterer.prototype['getMarkers'] = MarkerClusterer.prototype.getMarkers;
+MarkerClusterer.prototype['getMaxZoom'] = MarkerClusterer.prototype.getMaxZoom;
+MarkerClusterer.prototype['getStyles'] = MarkerClusterer.prototype.getStyles;
+MarkerClusterer.prototype['getTotalClusters'] =
+  MarkerClusterer.prototype.getTotalClusters;
+MarkerClusterer.prototype['getTotalMarkers'] =
+  MarkerClusterer.prototype.getTotalMarkers;
+MarkerClusterer.prototype['redraw'] = MarkerClusterer.prototype.redraw;
+MarkerClusterer.prototype['removeMarker'] =
+  MarkerClusterer.prototype.removeMarker;
+MarkerClusterer.prototype['removeMarkers'] =
+  MarkerClusterer.prototype.removeMarkers;
+MarkerClusterer.prototype['resetViewport'] =
+  MarkerClusterer.prototype.resetViewport;
+MarkerClusterer.prototype['repaint'] =
+  MarkerClusterer.prototype.repaint;
+MarkerClusterer.prototype['setCalculator'] =
+  MarkerClusterer.prototype.setCalculator;
+MarkerClusterer.prototype['setGridSize'] =
+  MarkerClusterer.prototype.setGridSize;
+MarkerClusterer.prototype['setMaxZoom'] =
+  MarkerClusterer.prototype.setMaxZoom;
+MarkerClusterer.prototype['onAdd'] = MarkerClusterer.prototype.onAdd;
+MarkerClusterer.prototype['draw'] = MarkerClusterer.prototype.draw;
+
+Cluster.prototype['getCenter'] = Cluster.prototype.getCenter;
+Cluster.prototype['getSize'] = Cluster.prototype.getSize;
+Cluster.prototype['getMarkers'] = Cluster.prototype.getMarkers;
+
+ClusterIcon.prototype['onAdd'] = ClusterIcon.prototype.onAdd;
+ClusterIcon.prototype['draw'] = ClusterIcon.prototype.draw;
+ClusterIcon.prototype['onRemove'] = ClusterIcon.prototype.onRemove;
\ No newline at end of file
diff --git a/js/snazzy-info-window.js b/js/snazzy-info-window.js
new file mode 100644
index 0000000..08b4c08
--- /dev/null
+++ b/js/snazzy-info-window.js
@@ -0,0 +1,758 @@
+(function (global, factory) {
+  if (typeof define === "function" && define.amd) {
+    define('SnazzyInfoWindow', ['module', 'exports'], factory);
+  } else if (typeof exports !== "undefined") {
+    factory(module, exports);
+  } else {
+    var mod = {
+      exports: {}
+    };
+    factory(mod, mod.exports);
+    global.SnazzyInfoWindow = mod.exports;
+  }
+})(this, function (module, exports) {
+  'use strict';
+
+  Object.defineProperty(exports, "__esModule", {
+    value: true
+  });
+
+  function _classCallCheck(instance, Constructor) {
+    if (!(instance instanceof Constructor)) {
+      throw new TypeError("Cannot call a class as a function");
+    }
+  }
+
+  var _createClass = function () {
+    function defineProperties(target, props) {
+      for (var i = 0; i < props.length; i++) {
+        var descriptor = props[i];
+        descriptor.enumerable = descriptor.enumerable || false;
+        descriptor.configurable = true;
+        if ("value" in descriptor) descriptor.writable = true;
+        Object.defineProperty(target, descriptor.key, descriptor);
+      }
+    }
+
+    return function (Constructor, protoProps, staticProps) {
+      if (protoProps) defineProperties(Constructor.prototype, protoProps);
+      if (staticProps) defineProperties(Constructor, staticProps);
+      return Constructor;
+    };
+  }();
+
+  function _possibleConstructorReturn(self, call) {
+    if (!self) {
+      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
+    }
+
+    return call && (typeof call === "object" || typeof call === "function") ? call : self;
+  }
+
+  function _inherits(subClass, superClass) {
+    if (typeof superClass !== "function" && superClass !== null) {
+      throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
+    }
+
+    subClass.prototype = Object.create(superClass && superClass.prototype, {
+      constructor: {
+        value: subClass,
+        enumerable: false,
+        writable: true,
+        configurable: true
+      }
+    });
+    if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
+  }
+
+  var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
+    return typeof obj;
+  } : function (obj) {
+    return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
+  };
+
+  // Global variables
+  var _classPrefix = 'si-';
+  var _root2 = 1.41421356237;
+  var _inverseRoot2 = 0.7071067811865474;
+  var _eventPrefix = 'snazzy-info-window-';
+  var _defaultShadow = {
+    h: '0px',
+    v: '3px',
+    blur: '6px',
+    spread: '0px',
+    color: '#000'
+  };
+  var _defaultOptions = {
+    placement: 'top',
+    pointer: true,
+    openOnMarkerClick: true,
+    closeOnMapClick: true,
+    closeWhenOthersOpen: false,
+    showCloseButton: true,
+    panOnOpen: true,
+    edgeOffset: {
+      top: 20,
+      right: 20,
+      bottom: 20,
+      left: 20
+    }
+  };
+
+  // Copy keys from the source into the target
+  function copyKeys(target, source) {
+    if (target && source) {
+      Object.keys(source).forEach(function (key) {
+        target[key] = source[key];
+      });
+    }
+  }
+
+  // We need to safely merge options from the defaults. This will make
+  // sure settings like edgeOffset are properly assigned.
+  function mergeDefaultOptions(opts) {
+    var copy = {};
+    copyKeys(copy, _defaultOptions);
+    copyKeys(copy, opts);
+    Object.keys(_defaultOptions).forEach(function (key) {
+      var obj = _defaultOptions[key];
+      if ((typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) === 'object') {
+        var objCopy = {};
+        copyKeys(objCopy, obj);
+        copyKeys(objCopy, copy[key]);
+        copy[key] = objCopy;
+      }
+    });
+    return copy;
+  }
+
+  // Parse a css attribute into the numeric portion and the units
+  function parseAttribute(attribute, defaultValue) {
+    // 1em, 1.0em, 0.1em, .1em, 1.    em
+    var re = /^(-{0,1}\.{0,1}\d+(\.\d+)?)[\s|\.]*(\w*)$/;
+    if (attribute && re.test(attribute)) {
+      var match = re.exec(attribute);
+      var number = match[1];
+      var units = match[3] || 'px';
+      return { value: number * 1, units: units, original: attribute };
+    }
+    if (defaultValue) {
+      return parseAttribute(defaultValue);
+    }
+    return { original: defaultValue };
+  }
+
+  // Set the html of a container. Should support both raw text and a single
+  // DOM Element.
+  function setHTML(container, content) {
+    if (container) {
+      // Clear out everything in the container
+      while (container.firstChild) {
+        container.removeChild(container.firstChild);
+      }
+      if (content) {
+        if (typeof content === 'string') {
+          container.innerHTML = content;
+        } else {
+          container.appendChild(content);
+        }
+      }
+    }
+  }
+
+  // Get the opposite of a given placement
+  function oppositePlacement(p) {
+    if (p === 'top') {
+      return 'bottom';
+    } else if (p === 'bottom') {
+      return 'top';
+    } else if (p === 'left') {
+      return 'right';
+    } else if (p === 'right') {
+      return 'left';
+    }
+    return p;
+  }
+
+  // Return the placement with the first letter capitalized
+  function capitalizePlacement(p) {
+    return p.charAt(0).toUpperCase() + p.slice(1);
+  }
+
+  // Convert the value into a Google Map LatLng
+  function toLatLng(v) {
+    if (v !== undefined && v !== null) {
+      if (v instanceof google.maps.LatLng) {
+        return v;
+      } else if (v.lat !== undefined && v.lng !== undefined) {
+        return new google.maps.LatLng(v);
+      }
+    }
+    return null;
+  }
+
+  // Export SnazzyInfoWindow even if google is not yet defined.
+  var getGoogleClass = function getGoogleClass() {
+    return typeof google !== 'undefined' ? google.maps.OverlayView : function noop() {};
+  };
+
+  var SnazzyInfoWindow = function (_getGoogleClass) {
+    _inherits(SnazzyInfoWindow, _getGoogleClass);
+
+    function SnazzyInfoWindow(opts) {
+      _classCallCheck(this, SnazzyInfoWindow);
+
+      var _this = _possibleConstructorReturn(this, (SnazzyInfoWindow.__proto__ || Object.getPrototypeOf(SnazzyInfoWindow)).call(this, opts));
+
+      if (typeof google === 'undefined') {
+        console.warn('Snazzy Info Window: Google Maps is not defined!'); //eslint-disable-line
+        return _possibleConstructorReturn(_this);
+      }
+      // Private properties
+      _this._html = null;
+      _this._opts = mergeDefaultOptions(opts);
+      _this._callbacks = _this._opts.callbacks || {};
+      _this._marker = _this._opts.marker;
+      _this._map = _this._opts.map;
+      _this._position = toLatLng(_this._opts.position);
+      _this._isOpen = false;
+      _this._listeners = [];
+
+      // This listener remains active when the info window is closed.
+      if (_this._marker && _this._opts.openOnMarkerClick) {
+        _this.trackListener(google.maps.event.addListener(_this._marker, 'click', function () {
+          if (!_this.getMap()) {
+            _this.open();
+          }
+        }), true);
+      }
+
+      // When using a position the default option for the offset is 0
+      if (_this._position && !_this._opts.offset) {
+        _this._opts.offset = {
+          top: '0px',
+          left: '0px'
+        };
+      }
+
+      // Validate the placement option
+      var p = opts.placement || _this._opts.position;
+      // The position variable was renamed to placement so we must type check
+      if (typeof p === 'string' || p instanceof String) {
+        p = p.toLowerCase();
+      }
+      if (p !== 'top' && p !== 'bottom' && p !== 'left' && p !== 'right') {
+        _this._opts.placement = _defaultOptions.placement;
+      } else {
+        _this._opts.placement = p;
+      }
+
+      // Validate the position option
+      p = _this._opts.position;
+      if (p !== undefined && p !== null && typeof p !== 'string' && !(p instanceof String)) {
+        _this._opts.position = p;
+      }
+
+      // Validate the other options
+      if (_this._opts.border === undefined || _this._opts.border === true) {
+        _this._opts.border = {};
+      }
+      if (_this._opts.pointer === undefined) {
+        _this._opts.pointer = _defaultOptions.pointer;
+      }
+      if (_this._opts.shadow === undefined || _this._opts.shadow === true) {
+        _this._opts.shadow = {};
+      }
+      return _this;
+    }
+
+    // Activate the specified callback and return the result
+
+
+    _createClass(SnazzyInfoWindow, [{
+      key: 'activateCallback',
+      value: function activateCallback(callback) {
+        var lambda = this._callbacks[callback];
+        return lambda ? lambda.apply(this) : undefined;
+      }
+    }, {
+      key: 'trackListener',
+      value: function trackListener(listener, persistent) {
+        this._listeners.push({ listener: listener, persistent: persistent });
+      }
+    }, {
+      key: 'clearListeners',
+      value: function clearListeners(clearPersistent) {
+        if (this._listeners) {
+          this._listeners.forEach(function (e) {
+            if (clearPersistent || !e.persistent) {
+              google.maps.event.removeListener(e.listener);
+              e.listener = null;
+            }
+          });
+          this._listeners = this._listeners.filter(function (e) {
+            return e.listener != null;
+          });
+        }
+      }
+    }, {
+      key: 'isOpen',
+      value: function isOpen() {
+        return this._isOpen;
+      }
+    }, {
+      key: 'open',
+      value: function open() {
+        var result = this.activateCallback('beforeOpen');
+        if (result !== undefined && !result) {
+          return;
+        }
+        if (this._marker) {
+          this.setMap(this._marker.getMap());
+        } else if (this._map && this._position) {
+          this.setMap(this._map);
+        }
+      }
+    }, {
+      key: 'close',
+      value: function close() {
+        var result = this.activateCallback('beforeClose');
+        if (result !== undefined && !result) {
+          return;
+        }
+        this.clearListeners();
+        this.setMap(null);
+      }
+    }, {
+      key: 'destroy',
+      value: function destroy() {
+        if (this.getMap()) {
+          this.setMap(null);
+        }
+        // Make sure to clear all persistent listeners
+        this.clearListeners(true);
+      }
+    }, {
+      key: 'setContent',
+      value: function setContent(content) {
+        this._opts.content = content;
+        if (this._html && this._html.content) {
+          setHTML(this._html.content, content);
+        }
+      }
+    }, {
+      key: 'setPosition',
+      value: function setPosition(latLng) {
+        this._position = toLatLng(latLng);
+        if (this._isOpen && this._position) {
+          this.draw();
+          this.resize();
+          this.reposition();
+        }
+      }
+    }, {
+      key: 'setWrapperClass',
+      value: function setWrapperClass(wrapperClass) {
+        if (this._html && this._html.wrapper) {
+          var w = this._html.wrapper;
+          w.className = _classPrefix + 'wrapper-' + this._opts.placement;
+          if (this._opts.border) {
+            w.className += ' ' + _classPrefix + 'has-border';
+          }
+          if (wrapperClass) {
+            w.className += ' ' + wrapperClass;
+          }
+        }
+        this._opts.wrapperClass = wrapperClass;
+      }
+    }, {
+      key: 'getWrapper',
+      value: function getWrapper() {
+        if (this._html) {
+          return this._html.wrapper;
+        }
+        return null;
+      }
+    }, {
+      key: 'draw',
+      value: function draw() {
+        if (!this.getMap() || !this._html) {
+          return;
+        }
+        if (!this._marker && !this._position) {
+          return;
+        }
+
+        // 1. Assign offset
+        var offset = this._opts.offset;
+        if (offset) {
+          if (offset.left) {
+            this._html.wrapper.style.marginLeft = offset.left;
+          }
+          if (offset.top) {
+            this._html.wrapper.style.marginTop = offset.top;
+          }
+        }
+        // 2. Set the background color
+        var bg = this._opts.backgroundColor;
+        if (bg) {
+          this._html.contentWrapper.style.backgroundColor = bg;
+          if (this._opts.pointer) {
+            this._html.pointerBg.style['border' + capitalizePlacement(this._opts.placement) + 'Color'] = bg;
+          }
+        }
+        // 3. Padding
+        if (this._opts.padding) {
+          this._html.contentWrapper.style.padding = this._opts.padding;
+          if (this._opts.shadow) {
+            this._html.shadowFrame.style.padding = this._opts.padding;
+          }
+        }
+        // 4. Border radius
+        if (this._opts.borderRadius) {
+          this._html.contentWrapper.style.borderRadius = this._opts.borderRadius;
+          if (this._opts.shadow) {
+            this._html.shadowFrame.style.borderRadius = this._opts.borderRadius;
+          }
+        }
+        // 5. Font Size
+        if (this._opts.fontSize) {
+          this._html.wrapper.style.fontSize = this._opts.fontSize;
+        }
+        // 6. Font Color
+        if (this._opts.fontColor) {
+          this._html.contentWrapper.style.color = this._opts.fontColor;
+        }
+        // 7. Pointer
+        // Check if the pointer is enabled. Also make sure the value isn't just the boolean true.
+        if (this._opts.pointer && this._opts.pointer !== true) {
+          if (this._opts.shadow) {
+            this._html.shadowPointer.style.width = this._opts.pointer;
+            this._html.shadowPointer.style.height = this._opts.pointer;
+          }
+          if (this._html.pointerBorder) {
+            this._html.pointerBorder.style.borderWidth = this._opts.pointer;
+          }
+          this._html.pointerBg.style.borderWidth = this._opts.pointer;
+        }
+
+        // 8. Border
+        if (this._opts.border) {
+          // Calculate the border width
+          var bWidth = 0;
+          if (this._opts.border.width !== undefined) {
+            bWidth = parseAttribute(this._opts.border.width, '0px');
+            this._html.contentWrapper.style.borderWidth = bWidth.value + bWidth.units;
+          }
+          bWidth = Math.round((this._html.contentWrapper.offsetWidth - this._html.contentWrapper.clientWidth) / 2.0);
+          bWidth = parseAttribute(bWidth + 'px', '0px');
+
+          if (this._opts.pointer) {
+            // Calculate the pointer length
+            var pLength = Math.min(this._html.pointerBorder.offsetHeight, this._html.pointerBorder.offsetWidth);
+            pLength = parseAttribute(pLength + 'px', '0px');
+
+            var triangleDiff = Math.round(bWidth.value * (_root2 - 1));
+            triangleDiff = Math.min(triangleDiff, pLength.value);
+
+            this._html.pointerBg.style.borderWidth = pLength.value - triangleDiff + pLength.units;
+
+            var reverseP = capitalizePlacement(oppositePlacement(this._opts.placement));
+            this._html.pointerBg.style['margin' + reverseP] = triangleDiff + bWidth.units;
+            this._html.pointerBg.style[this._opts.placement] = -bWidth.value + bWidth.units;
+          }
+          var color = this._opts.border.color;
+          if (color) {
+            this._html.contentWrapper.style.borderColor = color;
+            if (this._html.pointerBorder) {
+              this._html.pointerBorder.style['border' + capitalizePlacement(this._opts.placement) + 'Color'] = color;
+            }
+          }
+        }
+        // 9. Shadow
+        if (this._opts.shadow) {
+          // Check if any of the shadow settings have actually been set
+          var shadow = this._opts.shadow;
+          var isSet = function isSet(attribute) {
+            var v = shadow[attribute];
+            return v !== undefined && v != null;
+          };
+
+          if (isSet('h') || isSet('v') || isSet('blur') || isSet('spread') || isSet('color')) {
+            var hOffset = parseAttribute(shadow.h, _defaultShadow.h);
+            var vOffset = parseAttribute(shadow.v, _defaultShadow.v);
+            var blur = parseAttribute(shadow.blur, _defaultShadow.blur);
+            var spread = parseAttribute(shadow.spread, _defaultShadow.spread);
+            var _color = shadow.color || _defaultShadow.color;
+            var formatBoxShadow = function formatBoxShadow(h, v) {
+              return h + ' ' + v + ' ' + blur.original + ' ' + spread.original + ' ' + _color;
+            };
+
+            this._html.shadowFrame.style.boxShadow = formatBoxShadow(hOffset.original, vOffset.original);
+
+            // Correctly rotate the shadows before the css transform
+            var hRotated = _inverseRoot2 * (hOffset.value - vOffset.value) + hOffset.units;
+            var vRotated = _inverseRoot2 * (hOffset.value + vOffset.value) + vOffset.units;
+            if (this._html.shadowPointerInner) {
+              this._html.shadowPointerInner.style.boxShadow = formatBoxShadow(hRotated, vRotated);
+            }
+          }
+          if (this._opts.shadow.opacity) {
+            this._html.shadowWrapper.style.opacity = this._opts.shadow.opacity;
+          }
+        }
+
+        var divPixel = this.getProjection().fromLatLngToDivPixel(this._position || this._marker.position);
+        if (divPixel) {
+          this._html.floatWrapper.style.top = Math.floor(divPixel.y) + 'px';
+          this._html.floatWrapper.style.left = Math.floor(divPixel.x) + 'px';
+        }
+        if (!this._isOpen) {
+          this._isOpen = true;
+          this.resize();
+          this.reposition();
+          this.activateCallback('afterOpen');
+          google.maps.event.trigger(this.getMap(), _eventPrefix + 'opened', this);
+        }
+      }
+    }, {
+      key: 'onAdd',
+      value: function onAdd() {
+        var _this2 = this;
+
+        if (this._html) {
+          return;
+        }
+        // Used for creating new elements
+        var applyCss = function applyCss(element, args) {
+          if (element && args) {
+            for (var i = 0; i < args.length; i++) {
+              var className = args[i];
+              if (className) {
+                if (element.className) {
+                  element.className += ' ';
+                }
+                element.className += _classPrefix + className;
+              }
+            }
+          }
+        };
+        var newElement = function newElement() {
+          for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
+            args[_key] = arguments[_key];
+          }
+
+          var element = document.createElement('div');
+          applyCss(element, args);
+          return element;
+        };
+
+        this._html = {};
+
+        // 1. Create the wrapper
+        this._html.wrapper = newElement();
+        this.setWrapperClass(this._opts.wrapperClass);
+
+        // 2. Create the shadow
+        if (this._opts.shadow) {
+          this._html.shadowWrapper = newElement('shadow-wrapper-' + this._opts.placement);
+          this._html.shadowFrame = newElement('frame', 'shadow-frame');
+          this._html.shadowWrapper.appendChild(this._html.shadowFrame);
+
+          if (this._opts.pointer) {
+            this._html.shadowPointer = newElement('shadow-pointer-' + this._opts.placement);
+            this._html.shadowPointerInner = newElement('shadow-inner-pointer-' + this._opts.placement);
+            this._html.shadowPointer.appendChild(this._html.shadowPointerInner);
+            this._html.shadowWrapper.appendChild(this._html.shadowPointer);
+          }
+
+          this._html.wrapper.appendChild(this._html.shadowWrapper);
+        }
+
+        // 3. Create the content
+        this._html.contentWrapper = newElement('frame', 'content-wrapper');
+        this._html.content = newElement('content');
+        if (this._opts.content) {
+          setHTML(this._html.content, this._opts.content);
+        }
+
+        // 4. Create the close button
+        if (this._opts.showCloseButton) {
+          if (this._opts.closeButtonMarkup) {
+            var d = document.createElement('div');
+            setHTML(d, this._opts.closeButtonMarkup);
+            this._html.closeButton = d.firstChild;
+          } else {
+            this._html.closeButton = document.createElement('button');
+            this._html.closeButton.setAttribute('type', 'button');
+            this._html.closeButton.innerHTML = '&#215;';
+            applyCss(this._html.closeButton, ['close-button']);
+          }
+          this._html.contentWrapper.appendChild(this._html.closeButton);
+        }
+        this._html.contentWrapper.appendChild(this._html.content);
+        this._html.wrapper.appendChild(this._html.contentWrapper);
+
+        // 5. Create the pointer
+        if (this._opts.pointer) {
+          if (this._opts.border) {
+            this._html.pointerBorder = newElement('pointer-' + this._opts.placement, 'pointer-border-' + this._opts.placement);
+            this._html.wrapper.appendChild(this._html.pointerBorder);
+          }
+          this._html.pointerBg = newElement('pointer-' + this._opts.placement, 'pointer-bg-' + this._opts.placement);
+          this._html.wrapper.appendChild(this._html.pointerBg);
+        }
+
+        // Create an outer wrapper
+        this._html.floatWrapper = newElement('float-wrapper');
+        this._html.floatWrapper.appendChild(this._html.wrapper);
+
+        // Add the wrapper to the Google Maps float pane
+        this.getPanes().floatPane.appendChild(this._html.floatWrapper);
+
+        // Now add all the event listeners
+        var map = this.getMap();
+        this.clearListeners();
+        if (this._opts.closeOnMapClick) {
+          this.trackListener(google.maps.event.addListener(map, 'click', function () {
+            // _this2.close();
+          }));
+        }
+        if (this._opts.closeWhenOthersOpen) {
+          this.trackListener(google.maps.event.addListener(map, _eventPrefix + 'opened', function (other) {
+            if (_this2 !== other) {
+              // _this2.close();
+            }
+          }));
+        }
+
+        // Clear out the previous map bounds
+        this._previousWidth = null;
+        this._previousHeight = null;
+        this.trackListener(google.maps.event.addListener(map, 'bounds_changed', function () {
+          var d = map.getDiv();
+          var ow = d.offsetWidth;
+          var oh = d.offsetHeight;
+          var pw = _this2._previousWidth;
+          var ph = _this2._previousHeight;
+          if (pw === null || ph === null || pw !== ow || ph !== oh) {
+            _this2._previousWidth = ow;
+            _this2._previousHeight = oh;
+            _this2.resize();
+          }
+        }));
+
+        // Marker moves
+        if (this._marker) {
+          this.trackListener(google.maps.event.addListener(this._marker, 'position_changed', function () {
+            _this2.draw();
+          }));
+        }
+
+        // Close button
+        if (this._opts.showCloseButton && !this._opts.closeButtonMarkup) {
+          this.trackListener(google.maps.event.addDomListener(this._html.closeButton, 'click', function (e) {
+            e.cancelBubble = true;
+            if (e.stopPropagation) {
+              e.stopPropagation();
+            }
+            _this2.close();
+          }));
+        }
+
+        // Stop the mouse event propagation
+        var mouseEvents = ['click', 'dblclick', 'rightclick', 'contextmenu', 'drag', 'dragend', 'dragstart', 'mousedown', 'mouseout', 'mouseover', 'mouseup', 'touchstart', 'touchend', 'touchmove', 'wheel', 'mousewheel', 'DOMMouseScroll', 'MozMousePixelScroll'];
+        mouseEvents.forEach(function (event) {
+          _this2.trackListener(google.maps.event.addDomListener(_this2._html.wrapper, event, function (e) {
+            e.cancelBubble = true;
+            if (e.stopPropagation) {
+              e.stopPropagation();
+            }
+          }));
+        });
+
+        this.activateCallback('open');
+      }
+    }, {
+      key: 'onRemove',
+      value: function onRemove() {
+        this.activateCallback('close');
+        if (this._html) {
+          var parent = this._html.floatWrapper.parentElement;
+          if (parent) {
+            parent.removeChild(this._html.floatWrapper);
+          }
+          this._html = null;
+        }
+        this._isOpen = false;
+        this.activateCallback('afterClose');
+      }
+    }, {
+      key: 'getMapInnerBounds',
+      value: function getMapInnerBounds() {
+        var mb = this.getMap().getDiv().getBoundingClientRect();
+        var mib = {
+          top: mb.top + this._opts.edgeOffset.top,
+          right: mb.right - this._opts.edgeOffset.right,
+          bottom: mb.bottom - this._opts.edgeOffset.bottom,
+          left: mb.left + this._opts.edgeOffset.left
+        };
+        mib.width = mib.right - mib.left;
+        mib.height = mib.bottom - mib.top;
+        return mib;
+      }
+    }, {
+      key: 'reposition',
+      value: function reposition() {
+        if (!this._opts.panOnOpen || !this._html) {
+          return;
+        }
+        var mib = this.getMapInnerBounds();
+        var wb = this._html.wrapper.getBoundingClientRect();
+        var dx = 0;
+        var dy = 0;
+        if (mib.left >= wb.left) {
+          dx = wb.left - mib.left;
+        } else if (mib.right <= wb.right) {
+          dx = wb.left - (mib.right - wb.width);
+        }
+        if (mib.top >= wb.top) {
+          dy = wb.top - mib.top;
+        } else if (mib.bottom <= wb.bottom) {
+          dy = wb.top - (mib.bottom - wb.height);
+        }
+        if (dx !== 0 || dy !== 0) {
+          this.getMap().panBy(dx, dy);
+        }
+      }
+    }, {
+      key: 'resize',
+      value: function resize() {
+        if (!this._html) {
+          return;
+        }
+        var mib = this.getMapInnerBounds();
+        // Handle the max width
+        var maxWidth = mib.width;
+        if (this._opts.maxWidth !== undefined) {
+          maxWidth = Math.min(maxWidth, this._opts.maxWidth);
+        }
+        maxWidth -= this._html.wrapper.offsetWidth - this._html.content.offsetWidth;
+        this._html.content.style.maxWidth = maxWidth + 'px';
+
+        // Handle the max height
+        var maxHeight = mib.height;
+        if (this._opts.maxHeight !== undefined) {
+          maxHeight = Math.min(maxHeight, this._opts.maxHeight);
+        }
+        maxHeight -= this._html.wrapper.offsetHeight - this._html.content.offsetHeight;
+        this._html.content.style.maxHeight = maxHeight + 'px';
+      }
+    }]);
+
+    return SnazzyInfoWindow;
+  }(getGoogleClass());
+
+  exports.default = SnazzyInfoWindow;
+  module.exports = exports['default'];
+});
diff --git a/src/Plugin/views/style/CommonMap.php b/src/Plugin/views/style/CommonMap.php
index 893742a..f342872 100644
--- a/src/Plugin/views/style/CommonMap.php
+++ b/src/Plugin/views/style/CommonMap.php
@@ -163,6 +163,7 @@ class CommonMap extends StylePluginBase {
       $build['#attached']['library'][] = 'geolocation/geolocation.markerclusterer';
       $build['#attached']['drupalSettings']['geolocation']['commonMap'][$map_id]['markerClusterer'] = [];
       $build['#attached']['drupalSettings']['geolocation']['commonMap'][$map_id]['markerClusterer']['enable'] = TRUE;
+      $build['#attached']['drupalSettings']['geolocation']['commonMap'][$map_id]['markerClusterer']['advanced'] = $this->options['marker_clusterer_advanced'];
       $build['#attached']['drupalSettings']['geolocation']['commonMap'][$map_id]['markerClusterer']['imagePath'] = $this->options['marker_clusterer_image_path'];
       if (!empty($this->options['marker_clusterer_styles'])) {
         $build['#attached']['drupalSettings']['geolocation']['commonMap'][$map_id]['markerClusterer']['styles'] = json_decode($this->options['marker_clusterer_styles']);
@@ -170,6 +171,14 @@ class CommonMap extends StylePluginBase {
     }
 
     /*
+     * snazzy.
+     */
+    if (!empty($this->options['snazzy'])) {
+      $build['#attached']['library'][] = 'geolocation/geolocation.snazzy-info-window';
+      $build['#attached']['drupalSettings']['geolocation']['commonMap'][$map_id]['snazzy'] = TRUE;
+    }
+
+    /*
      * Dynamic map handling.
      */
     if (!empty($this->options['dynamic_map']['enabled'])) {
@@ -454,7 +463,9 @@ class CommonMap extends StylePluginBase {
     $options['marker_scroll_to_result'] = ['default' => 0];
     $options['marker_row_number'] = ['default' => FALSE];
     $options['id_field'] = ['default' => ''];
+    $options['snazzy'] = ['default' => FALSE];
     $options['marker_clusterer'] = ['default' => 0];
+    $options['marker_clusterer_advanced'] = ['default' => FALSE];
     $options['marker_clusterer_image_path'] = ['default' => ''];
     $options['marker_clusterer_styles'] = ['default' => []];
     $options['dynamic_map'] = [
@@ -737,6 +748,13 @@ class CommonMap extends StylePluginBase {
       '#default_value' => $this->options['show_raw_locations'],
     ];
 
+    $form['snazzy'] = [
+      '#group' => 'style_options][advanced_settings',
+      '#title' => $this->t('Use snazzy plugin.'),
+      '#type' => 'checkbox',
+      '#default_value' => $this->options['snazzy'],
+    ];
+
     $form['even_empty'] = [
       '#group' => 'style_options][advanced_settings',
       '#title' => $this->t('Display map when no locations are found'),
@@ -823,6 +841,17 @@ class CommonMap extends StylePluginBase {
       '#description' => $this->t('Various <a href=":url">examples</a> are available.', [':url' => 'https://developers.google.com/maps/documentation/javascript/marker-clustering']),
       '#default_value' => $this->options['marker_clusterer'],
     ];
+    $form['marker_clusterer_advanced'] = [
+      '#group' => 'style_options][marker_clusterer_settings',
+      '#title' => $this->t('Enable advanced clustering'),
+      '#type' => 'checkbox',
+      '#default_value' => $this->options['marker_clusterer_advanced'],
+      '#states' => [
+        'visible' => [
+          ':input[name="style_options[marker_clusterer]"]' => ['checked' => TRUE],
+        ],
+      ],
+    ];
     $form['marker_clusterer_image_path'] = [
       '#group' => 'style_options][marker_clusterer_settings',
       '#title' => $this->t('Cluster image path'),
@@ -877,9 +906,10 @@ class CommonMap extends StylePluginBase {
       if ($json_result === NULL) {
         $form_state->setErrorByName('style_options][marker_clusterer_styles', $this->t('Decoding style JSON failed. Error: %error.', ['%error' => json_last_error()]));
       }
-      elseif (!is_array($json_result)) {
-        $form_state->setErrorByName('style_options][marker_clusterer_styles', $this->t('Decoded style JSON is not an array.'));
-      }
+      // Commented json_decode without second param returns object.
+//      elseif (!is_array($json_result)) {
+//        $form_state->setErrorByName('style_options][marker_clusterer_styles', $this->t('Decoded style JSON is not an array.'));
+//      }
     }
 
     $this->validateGoogleMapsSettingsForm($form, $form_state, 'style_options');
